=encoding utf8

=head0 Listas y Arreglos

Ya hablamos en el capítulo anterior de la singularidad de Perl, en este
capítulo vamos a hablar sobre la pluralidad. La pluralidad en Perl esta
representada por las listas y los arreglos. 

Una lista es una colección ordenada de escalares. Un array es una variable que
contiene una lista. En Perl, estos dos términos se utilizan a menudo como si
fueran intercambiables. Pero, para ser precisos, una lista es datos, y un array
es una variable. En este sentido, puedes tener una lista de valores que no
estén contenidos en un array, pero cada variable de tipo array contiene una
lista (incluso si la lista esta vacía). Por ejemplo: 

=begin programlisting

    36
    12.4
    42
    "hola"
    1.72e30
    "bye\n"

=end programlisting

Cada elemento en un array o una lista, es una variable escalar independiente
con un valor independiente. Estos valores están ordenados, es decir, tienen un
secuencia particular desde el primer hasta el último elemento. Los elementos de
un array o una lista están C<indexados> por pequeños enteros comenzando por el
cero N<En Perl, es posible cambiar el número de inicio de un array o una lista
indexada. Larry luego considero esto como una mala característica y su (ab)uso
esta fuertemente desaconsejado> (0) y contando de uno en uno, entonces el 
primer elemento de cualquier array o lista es siempre el elemento cero (0). 

Puesto que cada elemento es un valor escalar independiente, una lista o una
matriz puede contener números, cadenas, valores undef, o cualquier
mezcla de diferentes valores escalares. Sin embargo, es más común tener todos
los elementos del mismo tipo, tales como una lista de títulos de libros (todas
son cadenas) o una lista de cosenos (todos son números).

Las matrices o listas pueden tener cualquier número de elementos. La lista mas
pequeña es aquella que no tiene elementos, mientras que la mas grande puede
llenar toda la memoria disponible. Una vez mas esto es parte de la filosofía de
Perl "No hay limites innecesarios".

=head1 Accediendo los Elementos de un Array    

Z<Accediendo los Elementos de un Array> 

Si ha usado arrays en otro lenguaje, no se debe sorprender al encontrar que
perl provee un mecanismo de subindice del array para referirse a un elemento
por un indice numérico. 

Los elementos de un array son enumerados usando una secuencia de enteros,
comenzando en cero (0) e incrementando de uno en uno para cada elemento. Por
ejemplo:

=begin programlisting

    $prueba[0] = "yabba";
    $prueba[1] = "dabba";
    $prueba[2] = "doo";

=end programlisting

El nombre del array en este caso "prueba", es de un espacio de nombres 
totalmente separado de los escalares, puedes tener una variable escalar 
llamada $prueba en el mismo programa, y perl va a tratarlas como cosas
diferentes y no va a confundirse. 

Puede usar un elemento de un array como por ejemplo $prueba[0] en cualquier
lugar como si se tratara de un escalar como $prueba. Por ejemplo, puede obtener
el valor de un elemento del array o cambiar su valor con algunas expresiones
cortas y prácticas que vimos en el capítulo anterior: 

=begin programlisting

    print $prueba[0];
    $prueba[2] = "diddley";
    $prueba[1] .= "whatsis"; 

=end programlisting

Por su puesto, el subindice puede ser cualquier expresión que devuelva un valor
numérico. Si no es un entero, automáticamente va a ser truncado al próximo
entero menor. Por ejemplo: 

=begin programlisting

    $number = 2.71828;
    print $prueba[$number - 1]; # Es lo mismo que imprimir $prueba[1]

=end programlisting

Si se indica un elemento en el subindice que este mas allá del final del
array, el valor correspondiente va a ser C<undef>. Al igual que con las
variables escalares, si nunca ha guardado un valor en una variable escalar,
pues entonces el valor de esta variable va a ser C<undef>. Por ejemplo: 

=begin programlisting

    $blank = $prueba[ 142_857 ]; # obtengo undef
    $blanc = $mel;               # escalar no usado $mel obtengo undef

=end programlisting

=head1 Indices Especiales para un Array    

Z<Indices Especiales para un Array> 

Si guardas en un elemento del array que esta mas allá del final del array,
este automáticamente se extiende hasta donde sea necesario, aquí no hay límite
de longitud, el límite básicamente es la memoria que Perl tenga disponible para
usar. Si Perl necesita crear elementos intermedios, estos son creados con
valores undef. Por ejemplo: 

=begin programlisting

    $rocks[0] = 'bedrock';
    $rocks[1] = 'slate';
    $rocks[2] = 'lava';
    $rocks[3] = 'crushed rock';
    $rocks[99] = 'schist';      # ahora hay 95 elementos undef

=end programlisting

Algunas veces necesitamos encontrar el ultimo elemento indexado en el array.
Para el array C<rocks> que hemos definido en el ejemplo anterior, el ultimo
indice del array es C<$#rocks>. Este valor no es igual a la cantidad de
elementos contenidos en el array, esto es porque hay un indice 0. 

=begin programlisting

    $end = $#rocks;                     # 99
    $numero_de_elementos = $end + 1;    
    $rocks[$#rocks] = 'hard rock';      # El último elemento.

=end programlisting


El uso del valor $#name como un indice, como vimos en el ejemplo anterior,
ocurre con tanta frecuencia que Larry proporciono un acceso directo: indices
negativos para el array contando desde el final del array. No valla a pensar
con esto que puede ir mas allá del inicio del array. Si tienes tres elementos
en el array, entonces los indices negativos válidos son: -1 (el último 
elemento), -2 (el elemento del medio), y -3 (el primer elemento). En la
práctica parece que no se suele usar esto, con la excepción del indice -1.   

=begin programlisting

    $rocks[ -1 ] = 'hard rock'; # una forma fácil de hacer el ultimo ejemplo
    $dead_rock = $rocks[-100];  # se obtiene 'bedrock'
    $rocks[ -200 ] = 'crystal'  # Error fatal !

=end programlisting

=head1 Listas Literales    

Z<Listas Literales> 

Un array (la forma de representar un valor de lista en el programa) es una
lista de valores separados por coma encerrados entre paréntesis. Estos valores
constituyen los elementos de la lista. Por ejemplo: 

=begin programlisting

    (1, 2, 3)   # Una lista de tres valores 1, 2 y 3
    (1, 2, 3,)  # La misma lista de tres valores (la ultima coma se ignora)
    ("prueba", 4.5) # dos valores,  "prueba" y 4.5
    ( )         # una lista vacía, cero elementos
    (1..100)    # Una lista de 100 enteros.

=end programlisting

El ultimo ejemplo, aparece el operador de rango C<..>. Este operador crea una
lista de valores contando desde el escalar que se encuentra a la izquierda
hasta el escalar de la derecha, uno a uno. Por ejemplo: 

=begin programlisting

    (1..5)      # lo mismo que (1, 2, 3, 4, 5)
    (1.7..5.7)  # la misma cosa, pero se truncan los valores.
    (5..1)      # Una lista vacía, solo se cuenta hacia arriba.
    (0, 2..6, 10, 12) # Esto es (0, 2, 3, 4, 5, 6, 10, 12)
    ($m..$n)    # rango determinado por los valores de $m y $n
    (0..$#rocks) # Usando el indice del array rocks. 

=end programlisting

Como puede ver en los últimos dos ejemplos, los elementos de una lista literal
no necesariamente son constantes, pueden ser expresiones que van a ser
evaluadas cada vez que el literal sea usado. Por ejemplo: 

=begin programlisting

    ($m, 17)        # Dos valores, el valor correspondiente de $m y 7
    ($m+$om, $p+$q) # Dos valores

=end programlisting

Por supuesto, la lista puede contener cualquier valor escalar, como esta lista
de cadenas: 

=begin programlisting

    ("walter", "lilibeth", "juan", "juan", "jose", "carlos")

=end programlisting

=head1 El atajo qw    

Z<El atajo qw> 

Resulta que las listas de palabras simples son necesarias con frecuencia en
programas en Perl. El atajo qw hace que sea mas fácil generarlas sin tener que
escribir un montón de comillas adicionales: 

=begin programlisting

    qw( walter lilibeth juan juan jose carlos );

=end programlisting

C<qw> significa "palabras citadas" del ingles "quoted words". Perl trata esto
como una cadena entre comillas simples en el contexto escalar, de manera que 
no podrá usar C<\n> o C<$prueba> en una lista C<qw> como si estuviera entre comillas dobles. 

Los espacios en blanco (caracteres como espacios, tabs, y nuevas lineas) son
descartados, y todo lo que queda se convierte en una lista de elementos.
Tomando en cuenta que el espacio en blanco se descarta, podemos escribir la
lista de la siguiente forma: 

=begin programlisting

    qw( walter 
        lilibeth
        juan
        juan
        jose
        carlos
    );

=end programlisting

El ejemplo anterior usa paréntesis como delimitador,  pero Perl actualmente
permite que uses cualquier caracter de puntuación como delimitador. Algunos
ejemplos mas comunes son: 

=begin programlisting

    qw( walter lilibeth juan juan jose carlos );
    qw! walter lilibeth juan juan jose carlos !;
    qw/ walter lilibeth juan juan jose carlos /;
    qw# walter lilibeth juan juan jose carlos #;
    qw{ walter lilibeth juan juan jose carlos };
    qw[ walter lilibeth juan juan jose carlos ];
    qw< walter lilibeth juan juan jose carlos >;

=end programlisting

Si necesita incluir el delimitador usado como parte de una cadena en uno de los
elementos, probablemente escogió el delimitador equivocado, pero incluso
podría hacerlo, escapando el delimitador con un C<\>. Ejemplo:

=begin programlisting

    qw! yahoo\! google ask msn ! # include yahoo! as an element

=end programlisting

Aunque el lema de perl es "Siempre Hay Mas De Una Forma De Hacer Las Cosas", se
preguntara, para que necesito todas estas formas de citar. Bueno, mas adelante
que hay otras formas de citar en Perl que son útiles en casos especiales. Por
ejemplo, ahora mismo podría necesitar hacer una lista de nombres de archivos
Unix, entonces podría hacerlo así: 

=begin programlisting

    qw{
        /usr/dict/words
        /home/elsanto/.vimrc 
    }

=end programlisting


=head1 Asignación de listas    

Z<Asignación de listas> 

De la misma forma que asignamos escalares a variables, podemos asignar valores
de listas a variables. Por ejemplo:

=begin programlisting

    ($walter, $lilibeth, $juan) = (25, 26, 30);

=end programlisting

Las tres variables en la lista de la izquierda,  reciben nuevos valores, como
si los asignara individualmente. Dado que la lista se constituye antes del
inicio de la asignación. Esto hace que sea fácil intercambiar los valores de 
dos variables en Perl: 

=begin programlisting

    ($walter, $lilibeth) = ($lilibeth, $walter); 
    ($betty[0], $betty[1]) = ($betty[1], $betty[0]);

=end programlisting

Pero que ocurre si el numero de variables (a la izquierda del signo de =) no es
igual al numero de valores (a la derecha del signo =) en una asignación de
lista. Los valores extra son simplemente ignorados. De igual manera si ocurre
lo contrario, las variables adicionales obtienen el valor C<undef>.

=begin programlisting

    ($fred, $barney) = qw< flintstone rubble slate granite >;
    ($wilma, $dino) = qw[flintstone];       # $dino obtiene undef.

=end programlisting

Ahora que puedes asignar listas, puedes crear un array de cadenas con una linea
de código como esta:

=begin programlisting

    ($rocks[0], $rocks[1], $rocks[2]]) = qw/talc mica feldspar/;

=end programlisting

Podemos referirnos a toda una matriz a través de una notación simple que posee
Perl. Solo tiene que usar una arroba (@) antes del nombre del array (y sin
corchetes de indices) para referirse a toda la matriz. Este sígil funciona a
ambos lados del operador de asignación. 

=begin programlisting

    @rocks  = qw/ bedrock slate lava /;
    @tiny   = ( );                      # una lista vacia 
    @giant  = 1..1e5;                   # una lista de 100.000 elementos
    @stuff  = (@giant, undef, @giant);  # una lista de 200.001 elementos

=end programlisting

C<@tiny> es una lista conformada por cero elementos. (Esto en particular no
pone undef dentro de la lista, pero lo podemos hacer de manera explicita como
se puede ver con la lista C<@stuff>).

El valor de una lista nueva a la que no se le ha asignado nada es C<()> de
lista vacía. Así como los valores escalares nacen con el valor C<undef> una
lista nace con el valor C<()> (lista vacía). 

Larry escogió el signo @ porque el lee $calar (scalar) y @rray (array), es una
buena regla nemotécnica para recordar.


=head1 Los operadores push y pop    

Z<Los operadores push y pop> 

Usted puede agregar nuevos elementos al fina de un array simplemente guardando
estos elementos con un indice nuevo mas grande. Pero los verdaderos
programadores de Perl no usan indices N<Esto por su puesto es una broma. Los
indices en Perl no son una fortaleza del lenguaje. Si usas pop, push y
operadores similares en lugar de usar indices, tu código va a ser generalmente
más rápido>. En las siguientes secciones explicaremos como trabajar con arrays
sin usar indices. 

Un uso común para un array es guardar información, en donde los nuevos valores
se añaden y se eliminan por la parte derecha de la lista (Este es el final de
la lista que contiene el ultimo elemento, con el indice mas alto). Estas
operaciones ocurren con la suficiente frecuencia como para tener sus propios
operadores especiales. 

El operador C<pop> saca el último elemento de la lista y lo retorna. Ejemplo:

=begin programlisting

    @array      = 5..9;
    $fred       = pop(@array);  # $fred = 9,  @array = (5, 6, 7, 8)
    $barney     = pop @array;   # $barney = 8,  @array = (5, 6, 7)
    pop @array;                 # @array = (5, 6) (El 7 fue descartado)

=end programlisting

El último ejemplo usamos C<pop> en un "contexto vacío", que es una manera
elegante de decir que el valor de retorno no va a ninguna parte. No hay nada
malo con el uso de pop de esta manera. 

Si la matriz esta vacía, pop no hace nada y devuelve C<undef>. 

Seguro noto que pop puede usarse sin los paréntesis. Esta es una regla general
en Perl, siempre y cuanto no cambie el sentido de la expresión, se pueden
remover los paréntesis. N<Un estudiante avanzado, va a reconocer que esto es
una tautología>

El operador contrario es C<push> que agrega elementos o una lista de elementos
al final de un array. Por ejemplo:

=begin programlisting

    push(@array, 0);            # @array ahora tiene (5, 6, 0)
    push @array, 8;             # @array ahora tiene (5, 6, 0, 8)
    push @array,  1..10;        # @array ahora tiene 10 elementos mas.
    @others = qw/ 9 0 2 1 0/; 
    push @array,  @others;      # @array ahora tiene 5 elementos nuevos (19)  

=end programlisting

Note que el primer argumento de C<push> o el único argumento que C<pop> require
debe ser una variable array. Hacer push y pop de listas literales no tiene
ningún sentido. 

=head1 Los operadores shift y unshift    

Z<Los operadores shift y unshift> 

Los operadores C<push> y C<pop> hacen cosas al final del array (o al lado
derecho del array). De manera similar, C<unshift> y C<shift> realizan las
operaciones correspondientes pero al principio del array (o al lado izquierdo
del array). Aquí hay algunos ejemplos: 

=begin programlisting

    @array = qw# walter lilibeth juan #;
    $m = shift(@array);         # $m = "dino", @array = ("fred", "barney")
    $n = shift @array;          # $n = "fred", @array = ("barney")
    shift @array;               # @array = (),  vacío
    $o = shift @array;          # $o = undef,  @array esta vacío
    unshift(@array, 5);         # @array ahora tiene un elemento en la lista
    unshift @array, 4;          # @array = (4, 5)
    @others = 1..3;
    unshift @array, @others;    # @array = (1, 2, 3, 4, 5)

=end programlisting

=head1 Interpolando Arrays en Cadenas    

Z<Interpolando Arrays en Cadenas> 

Así como los escalares, los valores array pueden ser interpolados en una cadena
de dobles comillas. Los elementos de un array son automáticamente separados por
espacios (Espacio en blanco es el separador por defecto contenido como valor en
la variable especial C<$">).

=begin programlisting

    @rocks = qw{ flintstone slate rubble };
    print "quartz @rocks limestone\n"; # imprime 5 rocas separadas por blanco

=end programlisting

No se agregan espacios en blanco antes o después de la interpolación, si usted
quiere esto, tendrá que hacerlo a mano. 

=begin programlisting

    print "Three rocks are: @rocks.\n";
    print "There's nothing in the parens (@empty) here.\n";


=end programlisting

Si de casualidad olvida que los array se interpolan entre dobles comillas, se
va a llevar una sorpresa cuando intente colocar un correo electrónico en una
cadena.

=begin programlisting

    $email = "walter@covetel.com.ve;    # MAL! Intentara interpolar @covetel

=end programlisting

Para poder hacer esto, deberá usar comillas simples o escapar el caracter @. 


=begin programlisting

    $email = "walter\@covetel.com.ve";  # Correcto
    $email = 'walter@covetel.com.ve'    # otra forma de hacerlo.

=end programlisting
















