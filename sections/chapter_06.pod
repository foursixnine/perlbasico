=head0 El mundo de las Expresiones Regulares

Perl posee muchas caracteristicas que lo distinguen de otros lenguajes. De
todas estas caracteristicas una de las mas importantes es el soporte solido de
expresiones regulares.  Este permite un manejo de cadenas rápido, flexible y
confiable.

Este poder tiene un precio. Las expresiones regulares actualmente son pequeños
programas con su propio lenguaje especial, metidos dentro de Perl. (Si, esta
pensando correctamente, va a aprender otro lenguaje de programación.)

En este capítulo, va a visitar el mundo de las expresiones regulares, en donde
probablemente podrás olvidar algunas cosas del mundo de Perl. Luego en un
capítulo siguiente, vamos a mostrarle donde es que este mundo encaja en el
mundo de Perl. 

Las expresiones regulares no son exclusivas de Perl, podemos encontrarlas en
C<sed> y C<awk>, C<procmail>, C<grep>, editores de texto como C<vim> e
C<emacs>.

=head1 ¿ Qué son las expresiones regulares ?

Una expresion regular, tambien llamada I<patrón> en Perl, es una plantilla en
donde una cadena determinada encaja o no encaja. Esto es, hay un número
infinito de cadenas de texto posibles; con un patrón de terminado que las
divide en dos grupos: las cadenas que encajan o coinciden, y aquellas que no. 

Un patrón puede aplicar a una sola cadena, o solo dos o tres, o a una docena,
o a cientos, o a un número infinito. O puede aplicar a todas excepto a una, o
excepto a un grupo, o excepto a un número infinito.  

Nos referimos a las expresiones regulares como pequeños programas con su propio
lenguaje de programación simple. Es un lenguaje simple porque los programas
tienen una sola tarea: mirar una cadena y decir "Cumple, esta cadena encaja en
el patron" o "No cumple, esta cadena no encaja en el patrón". Y esto es todo lo
que hace. 

Uno de los lugares donde probablemente halla visto las expresiones regulares es
en el comando de Unix C<grep>. Por ejemplo:

=begin screen

    $ grep 'flint.*stone' chapter*.pod
    chapter_02.pod:    ($fred, $barney) = qw< flintstone rubble slate granite >;
    chapter_02.pod:    ($wilma, $dino) = qw[flintstone];       # $dino obtiene undef.
    chapter_02.pod:    @rocks = qw{ flintstone slate rubble };
    chapter_05.pod:    $apellido{"fred"}       = "flintstone";
    chapter_05.pod:        "fred"	=> "flintstone",
    

=end screen

No debe confundir las expresiones regulares con los patrónes de archivo de la
shell llamados globs. Un glob tipico es el que usas cuando escribes *.pm en la
consola de Unix para coincidir con todos los archivos que terminen en .pm. 

=head1 Usando Patrones Simples    

Z<Usando Patrones Simples> 

Para verificar una cadena contra un patrón o expresión regular contenida en la
variable C<$_>, simplemente colocamos la cadena entre un par de barras, por
ejemplo: 

=begin programlisting

    $_ = "yabba dabba doo";
    if (/abba/){
        print "Matched ! \n";
    }

=end programlisting

La expresión /abba/ busca estas cuatro letras en la cadena contenida en C<$_>,
si la encuntra retorna un valor verdadero. En este caso, fue encontrada en mas
de una oportunidad, pero eso no causa ninguna diferencia. Si la encuentra,
coincide o hace match; si no la encuentra en toda la expresión, falla. 

Como evaluar una expresión regular devuelve verdadero o falso, esta evaluación
normalmente se encuentra en expresiones condicionales C<if> o C<while>.


Todas las secuencias de escape usuales que pueda colocar entre dobles comillas
estan disponibles en los patrones de expresiones regulares, entonces podría
usar el patron /coke\tsprite/ para probar la coincidencia de 11 caracteres de
coke,  un tab,  y sprite. 

=head1 Sobre los Metacaracteres    

Z<Sobre los Metacaracteres> 

Si los patrones solo verificaran cadenas de caracteres simples, nos serían muy
útiles en verdad. Esto es porque hay una número de caracteres especiales,
llamados I<metacaracteres> que tienen un significado especial en las
expresiones regulares. 

Por ejemplo, el punto (.) es un caracter comodin, hace match de cualquier
caracter excepto de una nueva linea. Entonces el patrón C</bet.y/> va a hacer
match para la cadena C<betty>. O va a hacer match de C<betsy>, o de C<bet=y> o
de cualquier otra cadena que tenga C<bet> seguida por cualquier caracter
(excepto una nueva linea) seguida por una C<y>. El punto siempre hace match de
un solo caracter.

Si quisiera usar el punto en un patrón, para evaluar la existencia de el punto
en la cadena, debe anteponer un backslash o barra invertida. Esta regla aplica
para todos los metacaracteres de expresiones regulares en Perl. 

=head1 Cuantifiacdores Simples    

Z<Cuantifiacdores Simples> 

Con frecuencia, tendrá algo que se repite en un patrón. El asterisco (*) indica
hacer match de el item que lo precede cero o mas veces. Entonces,
C</fred\t*barney/> hace match para cualquier número de caracteres tabs entre
C<fred> y C<barney>. Entonces,  va a hacer match para C<"fred\tbarney"> con un
tab,  C<"fred\t\tbarney"> con dos tabs, o C<"fred\t\t\tbarney"> con tres tabs,
o de C<"fredbarney">. 

Para hacer referencia a cualquier grupo de caracteres, usamos el punto y el
asterisco. Entonces, C<.*> va a hacer match de cualquier caracter, para
cualquier número de veces. 

Al asterisco (*) se le llama formalmente I<cuantificador>. Pero no es el unico
cuantificador; el signo (+) es otro. El signo + indica que va a hacer match de
el caracter anterior una o mas veces: C</fred +barney/> hace match si fred y
barney esta separados por uno o mas espacios y solo espacios. (El espacio, no 
es un metacaracter). Esto no hace match de C<fredbarney>, debido a que el signo
(+) indica que debe haber uno o mas espacios entre los dos nombres, entonces el
ultimo espacio es requerido. Puede ayudarle a recordar que el signo (+) indica
que el carácter que antepone al signo mas (+) puede estar opcionalmente
repetido. 

Existe un tercer cuantificador como el asterisco (*) y el signo mas (+), pero
un poco mas limitado. Es el signo de interrogación cerrando (?), el cual indica
que el elemento que se encuentra antes de él es opcional. Esto es, el item que
le precede, puede ocurrir una o ninguna vez. Entonces, si tenemos
C</bamm-?bamm/> hace match para C<bamm-bamm> o para C<bammbamm>. Esto es fácil
de recordar, diciendo: "La última cosa, ¿ puede estar ?, ¿ o no puede estar ?.

=head1 Agrupación de Patrones    

Z<Agrupación de Patrones> 

Como en matemáticas, los parentesis (C<()>) los usabamos para agrupar.
Entonces, los paréntesis son metacaracteres. Ejemplo, el patron /fred+/ hace
match de cadenas como C<fredddddddd>, pero, este tipo de cadenas no son del
mundo real. Ahora, el patrón C</(fred)+/> hace match de cadenas como
C<fredfredfred>, que es algo mas parecido a lo que tal vez tu quisieras.
¿ Y que pasaría con el patrón C</(fred)*/> ?, esto va a hacer match para
cadenas como "Hola, Mundo". 

Los paréntesis tambien nos dan la posibilidad de reusar parte de la cadena que
hizo match directamente. Podemos usar puntos de referencias para acceder a una
cadena que hizo match en los paréntesis. Un punto de referencia se escribe como
una barra invertida seguida por un número, como \1, \2, \n. El número indica el
grupo creado con los paréntesis. 

Cuando usamos paréntesis al rededor de un punto, vamos ha hacer match de
cualquier caracter que no sea una nueva linea. Podemos hacer match de nuevo al
caracter que hizo match entre los paréntesis usando el punto de referencia \1. 

=begin programlisting

    $_ = "abba";
    if (/(.)\1/){   # Hace match de 'bb'
        "Esto hace match para un caracter seguido de si mismo. \n";
    }


=end programlisting

El punto de referencia no tiene que estar precisamete justo a la derecha de el
grupo de paréntesis. El siguiente patrón,  hace match de cualquier caractere
que no sea una nueva linea despues del literal B<y>, y luego usamos el punto de
referencia C<\1> para indicar que queremos hacer match de los mismos cuatro
caracteres despues de el literal C<d>: 

=begin programlisting

    $_ = "yabba dabba doo";
    if (/y(....) d\1/){
        print "Hace match del conjunto de caracteres que estan antes y despues
        de el caractere literal d! \n";
    }

=end programlisting

Podemos usar multiples grupos de paréntesis, y cada grupo posee su propio punto
de referencia. Podemos hacer match de cualquier caracter que no sea una nueva
linea en grupos de paréntesis, seguido por cualquier otro caracter que no sea
una nueva linea en otro grupo de paréntesis. Despues de tener estos dos grupos,
usamos \1 para referirnos al primer grupo y \2 para referirnos al segundo
grupo. En efecto, con el próximo ejemplo, va ha hacer match si se encuentra el
palíndrome abba: 

=begin programlisting

    $_ = "yabba dabba doo";
    if (/y(.)(.)\2\1/){     # Hace match de 'abba'
        print "Hizo match para los caracteres despues de d y y \n";
    }

=end programlisting

Ahora, se debe estar haciendo una pregunta, ¿ Como se sabe que grupo obtiene 
que número ?. Afortunadamente, Larry hizo que esto fuera fácil de comprender
para los humanos: simplemente cuente el orden de apertura de los paréntesis. 

=begin programlisting

    $_ = "yabba dabba doo";
    if (/y((.)(.)\3\2) d\1/){
        print "Matched\n";
    }

=end programlisting

Probablemente es mas fácil que lo vea, si escribe la expresión regular que
forma que se observe cada parte por separado: 


=begin programlisting
    
    (           # Primera apertura de paréntesis
        (.)     # Seundo apertura de paréntesis
        (.)     # Tercera apertura de paréntesis 
        \2
        \3
    )

=end programlisting

En Perl 5.10 existe una numa forma para denotar un punto de referencia. En
lugar de usar un baclslash y un número, usamos C<\g{N}>, donde N es el número
del punto de referencia que desea usar.

Supongamos que debe usar un punto de referencia como parte de un patrón que
contiene un número. En esta expresión regular, nosotros vamos a usar C<\1> para
repetir el caracter que hizo match en los paréntesis seguido por la cadena
literal 11: 

=begin programlisting

    $_ = "aa11bb";
    if (/(.)\111/){
        print "Matched ! \n"; 
    }

=end programlisting

Perl va a tener que adivinar que significa eso. ¿ Es un \1, \11, o \111 ?. Perl
crea referencias como sea necesario, entonces el asume que eso significa \111.
Pero no tenemos 111 grupos de paréntesis, o 11 grupos, Perl va a quejarse
cuando intente compilar el programa. 

Con la notación \g{N}, evitamos la ambiguedad en la referencia y las partes
literales del patrón. 

=begin programlisting

    use 5.010;

    $_ = "aa11bb";
    if (/(.)\g{1}11/){
        print "Esto hace match \n";
    }

=end programlisting

