=encoding utf8

=head0 Entrada y Salida
   
Z<Entrada y Salida>

Ya hemos visto como hacer alguna entrada/salida, con el fin de hacer posible
algunos de los ejercicios. Pero ahora vamos a aprender más acerca de las 
operaciones de cobertura el 80% de la E/S que se necesita para la mayoría de
los programas. Si ya está familiarizado con la funcionamiento de la entrada
estándar, salida y error, que está delante del juego. Si no, vamos a conseguir
que alcanzó a finales de este capítulo. Por ahora, sólo piense en "estándar de 
entrada" como "el teclado", y "salida estándar" como "la pantalla".

=head1 Entrada para Entrada Estándar

Z<Entrada para Entrada Estándar> 

La lectura de el flujo de entrada estándar es fácil. Hemos estado haciendo ya
con la Operador <STDIN>. N<Lo que nosotros estamos llamando al operador de la
línea de entrada aquí, <STDIN>, en realidad es un operador de línea de entrada
(representada por el paréntesis angulares) en torno a un gestor de archivo.
Usted aprenderá acerca de controladores de archivo más adelante en este 
capítulo>. La evaluación de este operador en un contexto escalar le ofrece la
siguiente línea de entrada:

=begin programlisting

    $line = <STDIN>;        # lectura de la siguiente línea
    chomp($line);           # y chomp 
    chomp($line = <STDIN>); # lo mismo más idiomáticamente
 
=end programlisting

Dado que del operador de línea de entrada devolverá C<undef> cuando llegue al
final del archivo, esto es útil para no dejarlo caer fuera de los bucles:

=begin programlisting 

    while (<STDIN>) {
      print "I saw $_";
    } 

=end programlisting

Hay mucho que hacer en esa primera línea: estamos leyendo la entrada en una 
variable, la comprobación que es definida, y si está es (lo que significa que
no hemos llegado al final de la entrada) nos estamos quedando en el cuerpo del
bucle C<while>. Así, dentro del cuerpo del bucle, vemos las líneas, una tras 
otra en la línea C<$>. N<Usted probablemente ha notado que nosotros nunca 
completamos esa entrada. En este tipo de bucle, en realidad no se puede
colocar chomp en la expresión condicional, por lo que a menudo es el primer 
elemento en el cuerpo del ciclo, cuando es necesario. Vamos a ver ejemplos
de ese en la siguiente sección.> Esto es algo que usted querrá hacer con
bastante frecuencia, por lo que naturalmente, Perl tiene un acceso directo 
para ello. El acceso directo es el siguiente:


=begin screen

    Initialization of state variables in list context currently forbidden 

=end screen

L<ejercicios_03>






