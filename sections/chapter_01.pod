=encoding utf8

=head0 Variables Escalares y Listas

Z<Variables Escalares y Listas>

=head1  Fundamentos Teóricos

Z<Fundamentos Teóricos>

=head2 Variables

Z<Variables>

X<Variables>

Las variables se utilizan para almacenar información en una ubicación 
determinada. Existen varios tipos de variables y cada una de ellas se puede 
utilizar para un tipo determinado de información. Perl admite 3 tipos de 
variables principales: 

=over 

=item Escalares

=item Matries

=item Hash

=back

Las variables B<escalares> almacenan información simple, como números y cadenas 
de texto. 

Las B<matrices> almacenan listas de números y cadenas en las que cada elemento 
de la lista esta identificado por un número. 

Las variables B<hash> también almacenan listas de números y cadenas, pero los 
elementos individuos son identificados mediante cadenas que reciben el nombre
de llaves.
 
A diferencia de otros lenguajes, los distintos tipos de variables en Perl se
identifican mediante un carácter especial, de este modo B<$var> es una variable 
escalar, B<@var> es una matriz y B<%var> es un hash. Cada tipo de variable, 
tiene su propio espacio de nombres. Esto significa que, en el ejemplo siguiente,
cada una de las variables es una variable independiente, que contiene un 
fragmento de información diferente: 

=begin programlisting

    $var = "Hola Mundo";
    @var = qw/Walter Alejandro/;
    print $var, "\n"; 

=end programlisting

El resultado sera el siguiente: 

=begin screen

    Hola Mundo

=end screen

Pero el resultado de: 

=begin programlisting

    print @var, "\n";

=end programlisting

Seria el siguiente: 

=begin screen

    Walter Vargas

=end screen

=begin sidebar

Un nombre de variable debe comenzar con una letra y puede contener cualquier
combinación de letras, números y caracteres de subrayado B<_>. Cualquier otro
carácter sera tratado como un operador de Perl. 

=end sidebar

=head2  Variables Escalares.

Z<Variables Escalares>

Una variable escalar es la forma mas básica de contenedor de datos disponible 
en Perl. Los demás tipos de datos de Perl utilizan el tipo escalar como tipo de 
datos básico. Por ejemplo, una matriz es una matriz de escalares y una variable
hash esta compuesta por valores escalares. Las variables escalares solo pueden 
contener unidades indivisibles de información tal que: una variable escalar 
puede almacenar números, cadenas o referencias. 

Una variable escalar no puede contener valores múltiples. Mas adelante, en 
este capítulo vamos a ver sobre B<referencias>

Perl trata las cadenas de caracteres y los números de forma casi idéntica. 
No existe ninguna forma de definir una variable escalar para que contenga un 
número o una cadena; una variable escalar contiene, simplemente, un valor. 
Perl decidirá en el momento en que se utilice la variable si el valor debe 
interpretarse como un número o una cadena. 
Esto también se aplica a las referencias.

Una referencia puede apuntar a otra variable escalar, a una matriz o a una 
variable hash, o incluso a un objeto. Para definir o asignar un valor a una 
variable escalar, se debe especificar el valor y el nombre de variable mediante 
un signo igual (el operador B<=>). Por ejemplo: 

=begin programlisting

    $age = 26;

=end programlisting

De esta forma se almacenaría el valor 26 en la variable B<$age>. El valor 
asignado a la variable se denomina literal, puesto que se trata de un valor 
estático (no computado). Por su parte, la siguiente instrucción: 

=begin programlisting

    $pi = 3.1415126; 

=end programlisting

Significa que la variable B<$pi> debería ser un valor de coma flotante. 
Perl tratará de la misma forma la variable B<$age> y la variable B<$pi>. 

Tampoco existe una manera de especificar la precisión de un número. En teoría, 
todos los números se almacenan como valores de coma flotante (que equivalen a 
los valores de tipo double en C). Sin embargo, Perl también hará suposiciones 
cuidadosas e inteligentes basadas en el valor de la variable como resultado de
una determinada expresión. La aritmética con enteros da lugar a valores enteros,
mientras que los valores de coma flotante traduce los resultados a coma flotante
cuando se visualizan. Por otra parte, también se puede especificar un número de 
coma flotante utilizando una notación científica: 

=begin programlisting

    $speed_of_light = 2.997e08;

=end programlisting

Para las cadenas, Perl utiliza distintas comillas para definir el formato de 
las cadenas. Por ejemplo, tanto las comillas simples como las dobles sirven para
definir una cadena: 

=begin programlisting

    $nombre = "Walter";
    $fullname = "Walter A. Vargas M.";
    $book = "Perl complete reference";

=end programlisting

La diferencia esta en que las comillas dobles definen una cadena con 
B<interpolación>; es decir; el contenido de la cadena puede ser evaluado. Por lo 
tanto las siguientes instrucciones proporcionan resultados diferentes: 

=begin programlisting

    $nombre = 'Walter A Vargas';
    $msg = 'Hola $nombre';
    $realmsg = "Hola $nombre";

=end programlisting

El valor de B<$msg> se visualizara de la siguiente forma: 

=begin screen

    Hola $nombre\n

=end screen

Sin salto de linea (el carácter \n), mientras que el valor B<$realmsg> se
visualizara de la siguiente forma: 

=begin screen

    Hola Walter A Vargas

=end screen

Incluyendo el carácter de salto de linea. 

Es muy importante entender esta distinción, ya que afectara a muchas de las 
operaciones e instrucciones que se ejecuten en Perl, sin mencionar la
legibilidad de las cadenas que se muestren. 

También merece la pena señalar, tal y como dijimos anteriormente, que las 
variables escalares se pasan de un formato a otro automáticamente, con el fin 
de conseguir los resultados deseados. Por ejemplo: 

=begin programlisting

    $valor = '123';
    print $valor + 1, "\n";

=end programlisting

Este código, mostraría el valor 124. Perl convierte automáticamente el valor de
la cadena en un número antes de aplicar el operador y suma uno al valor. 
El salto de linea, representado mediante el carácter B<\n>, ya esta
especificado como una cadena y, por lo tanto, no es necesario convertirlo, pero
sí es interpretado.

Existen varios caracteres de barra invertida B<\> que son interpretados y el 
lector, probablemente, ya conocerá muchos de ellos. 

Por cierto, es posible asignar una única palabra a las variables escalares sin 
comillas: 

=begin programlisting

    $nombre = Walter

=end programlisting

Sin embargo, este tipo de instrucción es ambiguo y no se recomienda utilizarlo.
Si la variable Walter estuviera definida como una función, el valor de la
variable B<$nombre> sería el resultado obtenido de una llamada a la función
Walter.  Ademas esto no esta permitido cuando se usa el pragma B<strict>.

No es necesario definir previamente las variables; se crearan de forma 
automática cuando se utilicen por primera vez. Su valor inicial será nulo, 
ya sea "" para una cadena o 0 (cero) para un número. Dependiendo del lugar en
que se use, una variable escalar (y otros tipos de variables) se interpretara
de forma automática como cadena, número o como un valor booleano (true o false, 
verdadero o falso). Los distintos operadores y funciones necesitan y generan 
distintos valores escalares. Perl también incluye un valor especial para las 
variables escalares. 

El valor definido B<undef> se puede utilizar para identificar determinadas 
condiciones de error y la existencia o no de información de matrices o
variables hash. El valor undef se utiliza normalmente como valor de retorno de
una función que, de otra manera, proporcionaría un valor de 0, que podría ser
autentico.  Por ejemplo, el valor de un puntero de archivos en un descriptor de
archivos 
podría ser cero, por lo tanto que la función B<tell> genera el valor B<undef> 
si el valor no se puede determinar. 


=head2  Listas. 

Z<Listas>

Una matriz es una lista de variables escalares. Se puede utilizar una matriz
para almacenar una lista con información, de manera que funcione como una pila
o para actuar como un contenedor de estructuras de datos mas complejas. Los
valores escalares pueden ser cualquiera de los tipos de datos que se pueden
almacenar en una variable escalar: número, cadena o referencia. 

Una matriz se puede definir de varias formas diferentes, y al igual que las
variables escalares las matrices pueden ser generadas y devueltas mediante
funciones e instrucciones. El método mas básico consiste en definir una matriz
vacía: 

=begin programlisting

    @array = ();

=end programlisting

En Perl no es necesario definir variables antes de utilizarlas; se pueden
definir en el momento en que se desee comenzar a utilizarlas. El ejemplo
anterior es, por tanto, un ejemplo de como se define una matriz. 

Las variables escalares individuales de una matriz se denominan elementos y a
cada elemento se le asigna un número. Se puede utilizar una matriz como una
lista indexada de información escalar. Por ejemplo, se puede utilizar una
matriz como una lista de días de la semana, comenzando por el día Lunes: 

=begin programlisting

    @dias = (
        "Lunes",   "Martes", "Miercoles", "Jueves",
        "Viernes", "Sabado", "Domingo"
    );

=end programlisting

Este es el formato largo para definir previamente el contenido de una matriz.
Los siguientes ejemplos también llenan la matriz con la misma información

=begin programlisting

    @dias = qw/Lunes Martes Miercoles Jueves Viernes Sabado Domingo/;

    $dias[0] = "Lunes";
    $dias[1] = "Martes";
    ...
    $dias[6] = "Domingo";

=end programlisting

El primer ejemplo utiliza el operador B<qw> para entrecomillar de forma
automática las palabras que no lleven comillas, y los espacios separan las
palabras individuales en distintos elementos de la matriz. Observe que el
operador B<qw> devuelve una matriz que, a continuación, Perl asigna a la matriz
que se esta creando. Mas adelante veremos que el mismo operador se puede
utilizar para proporcionar listas a otras funciones sin tener que crear una
matriz con nombre.

=head2 Contexto    

Z<Contexto> 

El contexto de una función o instrucción se define como el valor de retorno
esperado. Esto nos permite usar una única función que devuelva diferentes
valores, dependiendo de lo que el usuario espera recibir. Por ejemplo, las dos
llamadas siguientes de la función B<getpwent> devuelven una lista o un escalar,
dependiendo de lo que se use en la asignación. 

=begin programlisting

    $name = getpwent(); # Contexto escalar

    ($name, $passwd, $uid, $gid) = getpwent(); # Contexto de Lista.

=end programlisting

En el primer caso, el usuario espera que la función devuelva un valor escalar,
porque quiere asignar el valor devuelto a un escalar. En el segundo caso el
usuario espera que el valor devuelto sea una lista, de nuevo porque ha
especificado que la información devuelta sea insertada en una lista de
escalares. 

Esto puede ser confuso, puesto que la mayoría de los otros lenguajes admiten un
solo tipo de valor de retorno. De hecho, es muy práctico, porque reduce la
cantidad de código requerido para conseguir diferentes resultados. Aqui hay
otro ejemplo, de nuevo tomando las funciones internas de Perl, que muestra la
flexibilidad que esto permite: 

=begin programlisting

    my $timestr = localtime(time);

=end programlisting

En este ejemplo el valor de $timestr consiste en una cadena compuesta por la
fecha y hora actuales. Por otra parte, podríamos usar la instrucción: 

=begin programlisting

    ( $sec, $min, $hor, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

=end programlisting

Ahora las variables individuales contienen los valores correspondientes
devueltos por localtime. 

=head1 Soluciones Inmediatas

Z<Soluciones Inmediatas> 


=head2 ¿Que es una variable escalar?    

Z<¿Que es una variable escalar?> 

Una variable escalar es el nombre que se le asigna un espacio de datos en
memoria, y los datos almacenados en ese espacio de datos pueden ser un número o
una cadena de caracteres.

Tip: De hecho una variable escalar puede además almacenar otro tipo de dato en
Perl: el tipo de datos indefinido, que , técnicamente hablando, no es ni un
numero ni una cadena de caracteres (mas adelante se trabajará con el tipo
indefinido B<undef>).

Las variables escalares son indefinidas en Perl (excepto las referencias, que
están fuertemente tipificadas), a diferencia de lenguajes como C, que insisten
en que se declare un tipo, tales como int o float, para cada variable. Perl
determina que tipo de dato es un escalar, un número, string, y así
sucesivamente, basado en el contexto de la operación. Puedes crear variables
escalares solo por referencias, un proceso llamado I<autovivification> (que
podremos ver mas adelante) en Perl. Los siguientes son algunos ejemplos:

=begin programlisting

    $x = 100;
    $y = 200;
    $warning = "Do you smeel smoke ?";

=end programlisting

Los escalares creados así son globales, lo que significa, que son accesibles
desde cualquier parte en el script actual (mas correctamente, en el paquete
actual), pero puedes también localizarlos usando las palabras claves B<my> y
B<local>. Te mostrare como localizarlos cuando cubramos el alcance de las
variables y discutamos las subrutinas.

=head2 Nombres de las variables escalares    

Z<Nombres de las variables escalares> 

El nombre que usaras para una variable escalar puede contener letras, números y
subrayado. Tales nombres deben comenzar con el símbolo B<$>, que evita que se 
produzcan conflictos con palabras reservadas de Perl. El nombre de una variable
escalar puede ser extenso; aunque la longitud depende de la plataforma, el 
nombre de la variable puede ser de al menos 255 caracteres de longitud.

=begin sidebar

Los nombres de las variables escalares tambien pueden contener comillas simples,
aunque en la practica esta obsoleto (esta característica sigue estando
disponible, pero se considera anticuada). 

=end sidebar

Es importante destacar que los nombres de las variables escalares son sensibles
a las mayúsculas y minúsculas, en este sentido B<$variable1> no es lo mismo que
B<$Variable1>. 

Después de iniciar con $, puedes comenzar el nombre de una variable con
cualquier letra o un subrayado. De hecho, puedes comenzar el nombre de la
variable con un número y estar compuesto todo por números. Se puede incluso
usar caracteres no alfanuméricos y sin subrayado en los nombres de las
variables. Si haces esto, pensaras que el nombre de la variable puede ser solo
un carácter despues de B<$>.

El símbolo $ es llamado B<prefijo de-referenciador>. Aquí puedes ver todos los 
prefijos de-referenciadores en Perl y para que se usan: 

=over

=item * B<$> variables escalares

=item * B<%> variables hash (arreglos asociativos)

=item * B<@> arreglos (listas)

=item * B<&> subrutinas

=item * B<Typeglobs> Por ejemplo, *myvar se encuentra para cualquier tipo de
myvar tales como @myvar, %myvar y así sucesivamente. 

=back

=head2 Declarando Variables    

Z<Declarando Variables> 


En Perl a diferencia de otros lenguajes de programación, no necesitas declarar
las variables escalares antes para usarlas. La primera vez que uses la
variable, Perl la creará si todavía no existe. 

=begin sidebar

Ten en cuenta la posibilidad de cometer errores de ortografía al momento de
nombrar la misma variable en otra parte del código. Podrías equivocarte al
momento de nombrarla y crear una totalmente nueva, sin tener ningún valor
asignado. Perl no considera esas equivocaciones de nombramiento como un error,
por lo tanto conseguirlos realizando un debug puede ser muy difícil.

=end sidebar

Sin embargo, los escalares creados de esta manera están disponibles para todo
el código a través del paquete actual, esto significa, que si no divides tu
código en paquetes, estarán disponibles en cualquier lugar en el script. Tales
variables escalares son llamadas globales y tienen alcance global; el alcance
de una variable es todo el código desde donde puedas acceder a esta.

Normalmente se limita el alcance de las variables, sin embargo, esto llegará a
a ser una consideración cuando comencemos a dividir el código dentro de 
bloque para crear subrutinas. Puedes declarar variables con alcance restringido
de dos maneras: usando las palabras reservadas B<my> y B<local>.

=head2 Usando operadores de asignación sobre escalares    

Z<Usando operadores de asignación sobre escalares> 

¿ Como introduces datos en una variable escalar ?, para hacer esto, se utiliza
el operador de asignación B<=>. Ejemplo: 

=begin programlisting

    $variable = 5;

=end programlisting

Asignar strings es exactamente igual: 

=begin programlisting

    $variable = "Hola Mundo";

=end programlisting

Además de las asignaciones sencillas usted asignar un valor a multiples
variables en la misma declaración: 

=begin programlisting

    $x = $y = $z = 1;

=end programlisting

En este caso a cada escalar se le asigna el mismo valor 1. 

Puedes asignar a cualquier B<lvalue> usando el operador de asignación B<=>. Si no
tiene idea de que es un lvalue, hecha un vistazo al siguiente tópico. 

Puedes usar diferentes operadores adicionales en las asignaciones a escalares.
Por supuesto, también puedes realizar sumas, restas, multiplicaciones y otras
como estas: 

=begin programlisting

    $x = $x + 2;
    $x = $x - 2;
    $x = $x * 5; 

=end programlisting

De hecho al igual que en C, puedes combinar operadores como +, -, y * con el
operador de asignación, lo que significa que puedes escribir los ejemplos
anteriores de la siguiente manera: 

=begin programlisting

    $x += 2;
    $x -= 2;
    $x *= 5; 

=end programlisting

En Perl, a diferencia de C, el operador de asignación crea un lvalue válido. 
Usando el operador de asignación combinado sería lo mismo que realizar la 
asignación y luego aplicar el otro operador sobre la variable que ha sido 
asignada. Por ejemplo: 

=begin programlisting

    ($grados += 100) *= 700;

=end programlisting

Es igual a: 

=begin programlisting

    $grados += 100;
    $grados *= 700;

=end programlisting

Para más información sobre los operadores disponibles en Perl, mas adelante 
serán presentados todos; hasta aquí solo se han presentado los operadores 
necesarios para continuar con los siguientes temas. 


=head2 ¿Que es un lvalue?    

Z<¿Que es un lvalue?> 

Un B<lvalue> es un elemento que sirve como un objeto de una asignación. El
término lvalue originalmente significa I<left value> (valor a la izquierda),
esto es para referirse a un valor que aparece a la izquierda, como el
siguiente: 

=begin programlisting

    $variable1 = 5;

=end programlisting

Un lvalue usualmente representa un espacio de datos en memoria, del cual puedes 
almacenar datos usando el nombre del lvalue. Cualquier variable sirve como 
un lvalue. De hecho, en Perl, hasta una asignación sirve como un lvalue. En 
este caso, he cortado el valor B<$input>, no el valor retornado por la 
operación de asignación: 

=begin programlisting

    chop ($input = 123);
    print $input;

=end programlisting

=begin screen

    12

=end screen


=head2 Usando números en variables escalares    

Z<Usando números en variables escalares> 

Perl soporta una variedad de formatos numéricos, como se muestran en la
siguiente lista: 

=over 

=item Entero (123)

=item Flotante (1.23)

=item Científico (1.23E4)

=item Hex (0x123)

=item Octal (0123)

=item Subrayado (1_234_567)

=back

Note en particular el formato numérico subrayado, el cual te permite dar
formato a dígitos en un número en grupos de tres para fácil reconocimiento de
números como el 1,234,567, de la forma que se muestra en el siguiente ejemplo: 

=begin programlisting

    $variable1 = 1_234_567;

=end programlisting

Pongamos mucha antención a este punto: I<precisión numérica>. Porque Perl es un
lenguaje multiplataforma, y por esto la precisión de los valores numéricos
difieren para diferentes máquina (desafortunadamente, no hay manera de listar
el tipo de precisión numérica con el que cuenta), podrias conseguir diferencias
con el mismo código sobre diferentes máquinas. Esto es una de las cosas para
tener en cuenta.

La siguiente información puede ser útil cuando estes pensando sobre la
presición numérica: Perl usa doubles para todos los calculos numéricos y para
almacenar números internamente. Los tipos Doubles son usualmente almacenados en
8 bytes y tienen un rango de -179769313486232E308-324 hasta 179769313486232E308
para valores positivos nada mal el rango de los valores posibles. 

=head2 Trabajando con el valor undef    

Z<Trabajando con el valor undef> 

¿ Que pasaría si usted usa una variable escalar antes de darle un valor ?, pues
nada serio, y definitivamente nada fatal. Las variables tienen el valor
especial B<undef> antes de la primera asignación. 

Como B<undef> automaticamente actua como el cero (0) cuando se usa en el
contexto numérico, es fácil hacer un acumulador numérico que inicie vacío, por
ejemplo: 

 =begin programlisting
 
    $n = 1;
    while ($n < 10){
        $sum += $n;
        $n += 2; 
    }
    print "El total fue: $sum \n"
 
 =end programlisting
 
Supongamos que usted ha decidido usar la función sysread para leer el texto de
unos archivos y pasarlo a la aplicación que esta escribiendo en Perl. Se sabe
que sysread retorna un escalar indicando cuantos bytes se están leyendo. Pero
¿que pasa al final de archivo?, ¿que clase de valor retornará sysread?, ¿porque
la función retorna un escalar, debe ser un número o un string, cierto?

Pues no, aparte de números y strings, las variables escalares pueden incluso
mantener el valor indefinido de Perl, llamado como ya digímos anteriormente
B<undef>. Este valor es retornado por algunas funciones, y puedes comprobarlo
usando una función llamada B<defined>. Si examinas el valor B<undef>
directamente, este es interpretado como un cero (0) en un contexto numérico y
como un string vacio B<""> en el contexto de cadenas de caracteres. También
puedes asignar a las variables el valor undef usando la función B<undef>. Este
ejemplo da a la variable B<$variable1> el valor 5: 

=begin programlisting

    $variable = 5;

=end programlisting

Y usando la función B<undef> sobre la variable, se puede convertir en variable
no definida. 

=begin programlisting

    $variable1 = 5;
    undef $variable1;

=end programlisting

Ahora, puedes probar si $variable1 esta definida usando la función B<defined>: 

=begin programlisting

    $variable1 = 5;
    undef $variable1;
    
    if (defined $variable1){
        print "\$variable1 esta definida. \n";
    } else {
        print "\$variable1 no esta definida \n";
    }

=end programlisting

En este caso, este código muestra el siguiente mensaje: 

=begin screen

    $variable1 no esta definida

=end screen

Varios operadores retornan undef cuando los argumentos están fuera del rango
esperado o no tienen sentido. 

Cuando se tienen activadas las advertencias en Perl, generalmente Perl advierte
sobre el uso no adecuado del valor undef, por ejemplo, si intenta copiar el
valor undef de una variable a otra, esto no va a causar ningún problema, pero
si intenta imprimir un valor undef, generalmente va a causar una advertencia. 

Resumiendo, las variables no definidas que poseen el valor B<undef>, en
contexto escalar es interpretado como cero (0) y en contexto de cadena de
caracteres es interpretado como vacío B<"">.


=head2 Declarando una constante    

Z<Declarando una constante> 

A muchos programadores les gusta usar constantes para evitar usar números
mágicos en el código (por ejemplo, $variable = 23477, el cual dice muy poco
acerca de donde proviene el valor). Usar constantes ayuda a centralizar todos
aquellos números juntos en tu código para una fácil modificación. Supongamos, qu 
recibes un email de un programador de C++, preguntando ¿por que no usas
constantes en tu código Perl?.  ¿puedes hacerlo?.

Resulta que Perl no tiene ningún tipo definido para las constantes numéricas,
pero tu puedes crear esos tipos por su cuenta. Para hacerlo, usas un B<typeglob>,
que es un tipo de dato que se puede representar como cualquier otra variable.
El prefijo de-referenciador para los B<typeglobs> es *.

Para crear una constante, asignas una referencia a una typeglob de la siguiente
manera. Aquí, eh creado una constante llamada MAXFILES para contener un máximo
número de archivos (eh capitalizado MAXFILES según la convencion de nombres de
constantes en C y C++):

=begin programlisting

    *MAXFILES = \100;

=end programlisting

Se puede acceder a esta constante usando B<$MAXFILES>, al igual que con
cualquier variable escalar: 

=begin programlisting

    *MAXFILES = \100;
    print "$MAXFILES \n";

=end programlisting

Si tratas de asignar un nuevo valor a B<$MAXFILES>, recibiras un error: 

=begin programlisting

    *MAXFILES = \100;
    print "$MAXFILES \n";
    $MAXFILES = 101; 

=end programlisting

=begin screen

    100
    Modification of a read-only value attempted at prueba.pl line 3.

=end screen

Este ejemplo ilustra una manera de crear y trabajar con constantes en Perl
usando el método con typeglobs. 

Existe una manera mas fácil y elegante de usar constantes en Perl, y es através
del pragma B<constant>

El pragma B<constant> le dice al compilador que el identificador dado tiene un
valor constante. Ejemplo: 

=begin programlisting

    use constant DEBUGGING => 0;
    use constant ONE_YEAR => 365.2425 * 24 * 60 * 60; 

    if (DEBUGGING){
        # hacer algo. 
    }

=end programlisting

Si necesita definir una lista considerable de constantes, entonces puede usar
la siguiente forma: 

=begin programlisting

	use constant {
	    SEC   => 0,
	    MIN   => 1,
	    HOUR  => 2,
	    MDAY  => 3,
	    MON   => 4,
	    YEAR  => 5,
	    WDAY  => 6,
	    YDAY  => 7,
	    ISDST => 8,
	};    

=end programlisting

Si requiere mas información sobre el uso del pragma constant, le recomendamos
revisar el manual B<perldoc constant>

=head2 Manejo de los valores de la verdad en Perl    

Z<Manejo de los valores de la verdad en Perl> 

=head3 La verdad y la mentira en Perl    

Z<La verdad y la mentira en Perl> 

El número 0, las cadenas B<'0'> y B<''>, la lista vacía B<()>, y el valor
B<undef> son todos falsos en el contexto booleano. Cualquier otro valor es
verdadero. La negación de un valor verdadero por los operadores B<!> o B<not>
retornan un valor falso especial. Cuando se evalua como una cadena, este valor
es tratado como B<''>, pero en el contexto numérico, es tratado como 0.  

Puedes almacenar valores verdaderos y falsos de dos maneras, utilizando
escalares, correspondientes a los dos contextos escalares. El contexto numérico
y el contexto de cadena. Hay una cosa que debemos recordar: en el contexto
numérico - 0 es falso y cualquier otro valor es verdadero; y en el contexto de
cadenas, la cadena vacía '' es falsa y cualquier otro valor (incluyendo valores negativos) es verdadero.

El hecho de que cualquier valor distinto de cero es verdadero es especialmente
útil en construcciones tales como bucles. Por ejemplo, este valor mantiene este
bucle while pasando por <> y siempre retorna algo, incluso si el usuario 
introduce una línea vacía (en este caso, <> retorna un carácter de nueva linea):

=begin programlisting

    while (<>) {
        print;
    }

=end programlisting

Los programadores a menudo se basan en el hecho de que cualquier cadena
diferente de B<cero (0)> o de B<vacio ('')> es verdadera. Se puede encontrar
esto muy frecuentemente en el código, por ejemplo, verifico el valor a dividir
para así evitar la división por cero. 

=begin programlisting

    if ($bt){
        $result - $top / $buttom; 
    } else {
        $result = 0;
    }

=end programlisting

Un punto para tomar en cuenta, sin embargo, es no probar contra valores falsos
cuando se esta evaluando el valor B<undef>. Algunas funciones retornan B<undef>
cuando no hay mas datos que leer, para evaluar esto, podemos usar la función
B<defined>. Por ejemplo: 

Sin hacer uso de la función defined: 

=begin programlisting

    print "Se obtuvo un valor" if ($value = returnvalue($index)); 

=end programlisting

Usando la función defined: 

=begin programlisting
    
    print "Se obtuvo un valor" if defined($value = returnvalue($index)); 

=end programlisting


			1. Conversión entre binario y decimal. 

=head2 Conversión entre binario y decimal    

Z<Conversión entre binario y decimal> 

Supongamos que usted está trabajando en su nueva calculadora binaria en perl, y
el jefe está muy contento con su progreso. Sin embargo, has llegado a un
pequeño inconveniente, ¿cómo mostrar los números binarios?

Esta no es una forma intrínseca para convertir de decimal a binario en Perl.
Sin embargo, puedes usar las funciones pack y unpack para convertir los números
en una cadena de dígitos binarios y viceversa. 

=head3 Decimal a binario    

Z<Decimal a binario> 

Para convertir un número decimal a una cadena de dígitos binarios, primero se 
debe hacer B<pack> usando la plantilla B<network byte order> (tambien llamado
B<big-endian order>, lo que significa que el bit mas significante va de
primero) y luego debes hacer B<unpack> de el resultado bit a bit, de la siguiente
manera: 


=begin programlisting

    $decimal = 4;
    $binario = unpack("B32", pack("N", $decimal));
    print $binario;

=end programlisting

=begin screen

    00000000000000000000000000000100

=end screen

=head3 Binario a decimal    

Z<Binario a decimal> 

Para convertir una cadena binaria a un número decimal, debes hacer justamente
el procedimiento inverso al punto anterior. Ejemplo: 

=begin programlisting

    $decimal = 4;
    $binario = unpack("B32", pack("N", $decimal));
    $newdecimal = unpack("N", pack("B32",$binario));
    print $newdecimal;
    
=end programlisting
