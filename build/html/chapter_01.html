<html>
<body>
<link rel='stylesheet' href='style.css' type='text/css'>

<h1>Datos Escalares</h1>

<h2>Números</h2>

<p>Aunque los números y las cadenas con frecuencia se pueden tratar como escalares, es útil observarlos inicialmente por separado. Vamos a ver primero los números y luego pasamos a las cadenas.</p>

<h3>Todos los números internamente tienen el mismo formato</h3>

<p><a name="Todos los números internamente tienen el mismo formato"></p>

<p>Como vera en los próximos párrafos, se puede especificar tanto números enteros (como 255 o 2001) y números de coma flotante (números reales con puntos decimales, como 3.1416 o 1.35 x 1025). Pero internamente, Perl calcula valores punto flotantes de doble precisión. Esto significa que no hay valores enteros internamente en Perl. Una constante entera en Perl es tratada como su valor equivalente en coma flotante. Probablemente no se dará cuenta de la conversión, deje de buscar las distintas operaciones con enteros (en oposición a las operaciones de punto flotante), porque simplemente no existen. <font class="footnote"> (footnote: Existe un pragma llamado Integer, que permite realizar operaciones con enteros en lugar de punto flotante, pero es otra cosa, y no es de lo que estamos hablando en este punto)</font></p>

<h3>Literales de punto flotante</h3>

<p><a name="Literales de punto flotante"></p>

<p>Un literal es la forma en que un valor se representa en el código fuente en Perl. Un literal no es el resultado de una operación de calculo o de una operación de I/O. Es datos escritos directamente en el código fuente.</p>

<p>Un literal de coma flotante, ya debe serle familiar. Números con y sin punto flotante también son permitidos (incluyendo el prefijo opcional mas y menos), y de remate el indicador de notación exponencial E.</p>

<div class="programlisting">

<pre><code>    1.25 
    255.000 
    255.0 
    7.25e45 
    &minus;6.5e24
    &minus;12e-24 
    &minus;1.2E-23</code></pre>

</div>

<h3>Literales Enteros</h3>

<p><a name="Literales Enteros"></p>

<p>Los literales enteros son muy sencillos de expresar, ejemplo:</p>

<div class="programlisting">

<pre><code>    0
    2001
    -40
    42
    469
    61298040283768</code></pre>

</div>

<p>El último número es un poco difícil de leer, Perl permite underscores para mayor claridad con los literales enteros, de modo que puede escribir ese último número de la siguiente manera:</p>

<div class="programlisting">

<pre><code>    61_298_040_283_768</code></pre>

</div>

<p>Este es el mismo número, solo que se ve un poco diferente para nosotros, los humanos. Podría pensar que se deberían usar comas en lugar de esto, pero las comas ya tienen un propósito mas importante en Perl.</p>

<h3>Literales enteros no decimales</h3>

<p><a name="Literales enteros no decimales"></p>

<p>Como en otros lenguajes de programación Perl permite especificar números que no son de base 10 (decimal). Literales de base 8 (Octal) deben comenzar con un 0, los literales de base 16 (Hexadecimal) deben comenzar con 0x y los literales binarios (base 2) deben comenzar con 0b.* Los dígitos hexadecimales de la A hasta la F, representan los valores de los dígitos convencionales del 10 al 15.</p>

<div class="programlisting">

<pre><code>    0377        # 377 octal, same as 255 decimal
    0xff        # FF hex, also 255 decimal
    0b11111111 # also 255 decimal</code></pre>

</div>

<p>Estos tres números, son la misma cosa para Perl, aunque para nosotros, los humanos tengan un aspecto diferente. No hay ninguna diferencia con respecto a Perl en escribir 255.000 o 0xFF. Así que elija la representación que tenga mas sentido para usted.</p>

<h3>Operadores numéricos</h3>

<p><a name="Operadores numéricos"></p>

<p>Perl provee operadores típicos de suma, resta, multiplicación y división. Ejemplo:</p>

<div class="programlisting">

<pre><code>    2 + 3       # 2 plus 3, or 5
    5.1 &minus; 2.4 # 5.1 minus 2.4, or 2.7
    3 * 12      # 3 times 12 = 36
    14 / 2      # 14 divided by 2, or 7</code></pre>

</div>

<p>Perl también soporta el operador de módulo (%). El valor de la expresión 10 % 3 es el resto de la división de 10 entre 3, que es 1. Adicionalmente Perl provee el valor por potenciación tipo FORTRAN (**) que todos anhelaron en C y Pascal. El operador esta representado por el doble asterisco (**), entonces podemos tener 2 ** 3 que es dos elevado a la tercera potencia. <font class="footnote"> (footnote: El resultado de una operación de módulo cuando uno o mas valores negativos están involucrados puede variar dependiendo de la implementación de Perl, tenga cuidado)</font></p>

<h2>Strings o Cadenas de Caracteres</h2>

<p><a name="Strings o Cadenas de Caracteres"></p>

<p>Las cadenas son secuencias de caracteres (como hola). Las cadenas pueden contener cualquier combinación de los caracteres. La cadena mas corta posible no tiene caracteres. La cadena mas larga llena toda la memoria, aunque no podría hacer mucho con esto.</p>

<p>Una cadena típica, son secuencias de letras, números y signos de puntación contenidos en el rango ASCII 32 al 126.</p>

<p>Como los números, las cadenas tienen una representación literal, que es la forma en que se representa una cadena en un programa en Perl. Los literales de cadenas vienen en dos formatos diferentes. Cadenas encerradas en comillas simples y cadenas encerradas en comillas dobles.</p>

<h3>Cadenas en comillas simples</h3>

<p><a name="Cadenas en comillas simples"></p>

<p>Las comillas simples, no son parte de la cadena, están allí para que Perl identifique el principio y el final de la cadena. Cualquier carácter que no sea una comilla simple o una barra invertida entre las comillas va a estar representado a si mismo en la cadena. Ejemplo:</p>

<div class="programlisting">

<pre><code>    &#39;fred&#39;          # those four characters: f, r, e, and d
    &#39;barney&#39;    # those six characters
    &#39;&#39;          # the null string (no characters)
    &#39;Esto\&#39;D evita que el apostrofe rompa la cadena&#39;
    &#39;El &uacute;ltimo caracter de esta linea es un backslash \\&#39;
    &#39;Hola \n&#39;   # Hola seguido por un backslash seguido por una n
    &#39;Hola 
    Mundo &#39;     # Hola, salto de linea, mundo (11 caracteres en total) 
    &#39;\&#39;\\&#39;      # Comilla simple seguida por un backslash. 
=end programlisting</code></pre>

<p>Note que \n dentro de comillas simples no es interpretado como un salto de linea.</p>

<h3>Cadenas en comillas dobles</h3>

<p><a name="Cadenas en comillas dobles"></p>

<p>De igual manera, es una cadena de caracteres, solo que en comillas dobles, y ahora la barra invertida tiene el poder especial de especificar caracteres de control, o cualquier caracteres a través de representaciones octales y hexadecimales. Estas son algunas de las cadenas entre comillas dobles:</p>

<div class="programlisting">

<pre><code>    &quot;larry&quot;         # es lo mismo que &#39;larry&#39;
    &quot;hello world\n&quot; # hello world y un salto de linea
    &quot;El ultimo caracter de esta linea es una comilla doble: \&quot;&quot;
    &quot;Cafe \t coca&quot;  # Cafe,  tabulador,  coca.</code></pre>

</div>

<p>Puede ver una tabla de las secuencias de escape disponibles en Perl, en el manual <b>perlrebackslash</b></p>

<div class="screen">

<pre><code>    $ perldoc perlrebackslash</code></pre>

</div>

<p>Otra caracteristica interesante de las cadenas de caracteres en doble comillas es la interpolación.</p>

<h3>Operadores de cadenas de caracteres</h3>

<p><a name="Operadores de cadenas de caracteres"></p>

<p>Los valores de cadenas se pueden concatenar con el operador <b>.</b>, esto no altera la cadena, simplemente la concatena, así que el resultado es una cadena mas, disponible para una operación o asignar a una variable. Ejemplo:</p>

<div class="programlisting">

<pre><code>    &quot;Hello&quot; . &quot;World&quot;           # HelloWorld
    &quot;Hello&quot; . &#39; &#39; . &quot;World&quot;     # Hello World
    &quot;Hello World&quot; .  &quot;\n&quot;       # Hello World\n</code></pre>

</div>

<p>Un operador especial de cadenas, es el operador de repetición, que consiste en la letra minúscula x. Este operador toma a su operando de la izquierda (una cadena) y hace tantas copias concatenadas de la misma como indica su operando de la izquierda (un número). Ejemplo:</p>

<div class="programlisting">

<pre><code>    &quot;perl&quot;x3        # es perlperlperl
    &quot;perl&quot;x(3+5)    # es perlperlperlperlperlperlperlperl
    5x4             # es 5555</code></pre>

</div>

<h3>Conversión automática entre números y cadenas</h3>

<p><a name="Conversión automática entre números y cadenas"></p>

<p>En su mayor parte, Perl convierte entre números y cadenas según sea necesario. ¿ Como saber que necesita ? todo depende del operador que este usando en el valor escalar. Si el operador espera un número (como el operador +), Perl va a ver el valor como un número. Si el operador espera una cadena (como . o x) entonces Perl va a ver el valor como una cadena. Así que no tiene que preocuparse por la diferencia entre los números y las cadenas, solo tiene que preocuparse por los operadores adecuados y perl hará todo el trabajo. Ejemplos:</p>

<div class="programlisting">

<pre><code>    &quot;12&quot; * 3        # es 36
    &quot;Z&quot; . 5 * 7     # es Z35</code></pre>

</div>

<h2>Warnings o Advertencias</h2>

<p><a name="Warnings o Advertencias"></p>

<p>Perl puede avisarle cuando vea algo sospechoso en su programa. Para correr un programa con las advertencias activadas debe usar la opción <b>-w</b> en la linea de comandos.</p>

<div class="screen">

<pre><code>    $ perl -w mi_programa.pl</code></pre>

</div>

<p>Si prefiere tener siempre activadas las advertencias, entonces puede indicarlo en la linea #!</p>

<div class="programlisting">

<pre><code>    #!/usr/bin/perl -w</code></pre>

</div>

<p>A partir de Perl 5.6 en adelante, puedes activar las advertencias a través del pargma <b>warnings</b></p>

<div class="programlisting">

<pre><code>    #!/usr/bin/perl
    use warnings; </code></pre>

</div>

<p>Ahora, Perl va a advertirle cuando use '12perl42' como si se tratara de un número.</p>

<div class="screen">

<pre><code>    Argument &quot;12perl42&quot; isn&#39;t numeric</code></pre>

</div>

<p>Por su puesto, las advertencias son para los programadores, no para los usuarios finales. Si las advertencias no van a ser vistas por un programador, pues probablemente sean inútiles.</p>

<p>Las advertencias no van a cambiar el funcionamiento de su programa, salvo que ahora Perl se queja de vez en cuando. Si recibe un mensaje que no entiende, se puede conseguir una mayor descripción con el pragma <b>diagnostics</b>. La página del manual <b>perldiag</b> contiene los tipos de advertencias.</p>

<div class="programlisting">

<pre><code>    #!/usr/bin/perl 
    use diagnostics;</code></pre>

</div>

<h2>Variables Escalares</h2>

<p><a name="Variables Escalares"></p>

<p>Una variable es un nombre para un contenedor que posee uno o mas valores. El nombre de la variable va a ser el mismo durante la ejecución del programa, pero el contenido puede variar durante la ejecución del mismo.</p>

<p>Una variable escalar, almacena un valor escalar simple. El nombre de una variable escalar comienza con el signo dolar ($)<font class="footnote"> (footnote: Esto es llamado sígil en lengua Perl)</font> seguido por algo que vamos a llamar identificador Perl: una letra o un guion bajo, y luego posiblemente, mas letras o dígitos o guiones bajos. Otra forma de verlo, es que esta formado por caracteres alfanuméricos y guiones, pero no puede comenzar con un dígito. Se distingue entre mayúsculas y minúsculas, la variable $perl es distinta de la variable $Perl y $PERL. Y todas las letras, signos y guiones bajos son significativos. Por lo que:</p>

<div class="programlisting">

<pre><code>    $una_variable_muy_muy_larga_que_termina_en_1</code></pre>

</div>

<p>Es diferente a</p>

<div class="programlisting">

<pre><code>    $una_variable_muy_muy_larga_que_termina_en_2 </code></pre>

</div>

<p>Las variables escalares pueden ser referenciadas usando un & luego del sígil $, con lo que quedaría $&.</p>

<h3>Colocando nombres adecuados a las variables</h3>

<p><a name="Colocando nombres adecuados a las variables"></p>

<p>Los nombres cortos en las variables, son útiles cuando la vida de la variable es de apenas 3 o 4 lineas, pero cuando la variable va a tener vida durante todo el programa o la función, vale la pena colocar un nombre que describa fácilmente el contenido de la variable.</p>

<p>Del mismo modo, el uso de guion abajo, puede ser útil para separa las palabras, esto hace un nombre de variable fácil de leer y entender, sobre todo si se trabaja con programadores cuya lengua materna es diferente a la suya.</p>

<p>La mayoria de las variables en Perl van a estar escritas en minúsculas, las variables en donde todas las letras son mayúsculas, normalmente son variables especiales como $ARGV.</p>

<p>Cuando el nombre de la variable tiene mas de una palabra, alguna gente prefiere usar guiones bajos (como $esta_es_una_variable) y otros prefieren usar $estaEsUnaVariable. Solo sea consistente.</p>

<h3>Asignación de variables escalares</h3>

<p><a name="Asignación de variables escalares"></p>

<p>La operación mas common en las variables escalares es la asignación, pues es la forma de darle valor a una variable. El operador de asignación en Perl es el signo igual (=), el nombre de la variable va a la izquierda y el valor de la variable a la derecha. Ejemplos:</p>

<div class="programlisting">

<pre><code>    $perl       = 17; 
    $prueba     = &#39;hola&#39;;
    $prueba     = $perl + 3;
    $prueba     = $prueba * 2;
    </code></pre>

</div>

<h3>Operadores de asignación binarios</h3>

<p><a name="Operadores de asignación binarios"></p>

<p>Expresiones como $perl = $perl + 5, aparecen frecuentemente en el código, como una manera rápida de alterar el valor de la variable. Hay una manera mas corta de hacer esto, usando el operador de asignación binario. Casi todos los operadores binarios que computan un valor, tienen un operador de asignación binario. Ejempo, las siguientes dos lineas son equivalentes:</p>

<div class="programlisting">

<pre><code>    $perl = $perl + 5;      #sin el operador de asignaci&oacute;n binario
    $perl += 5;             #con el operador de asignaci&oacute;n binario</code></pre>

</div>

<p>Tambien es equivalente:</p>

<div class="programlisting">

<pre><code>    $perl = $perl * 5;
    $perl *= 5;</code></pre>

</div>

<p>Para cada caso, los operadores alteran el valor correspondiente de la variable, colocando el valor resultante de la operación.</p>

<p>Otro operador de asignación común biene dado por el operador de concatenación de cadenas (.) con lo que obtenemos el operador (.=)</p>

<div class="programlisting">

<pre><code>    $str = $str . &quot; &quot;;
    $str .= &quot; &quot;;</code></pre>

</div>

<p>Casi todos los operadores binarios son válidos, por ejemplo puede usar el operador binario de potencia de la siguiente manera:</p>

<div class="programlisting">

<pre><code>    $numero **= 3;</code></pre>

</div>

<h2>Salida con Print</h2>

<p><a name="Salida con Print"></p>

<p>Es una buena idea que sus programas produzcan algún tipo de salidas por pantalla, de lo contrario, la gente pensara que el programa no esta haciendo nada.</p>

<p>El operador Print() hace esto posible, este toma un argumento escalar y lo pone sin embellesimiento en la salida estandar. Ejemplo:</p>

<div class="programlisting">

<pre><code>    print &quot;hello world\n&quot;;      # imprime hello world y un salto de linea.
    print &quot;Y la respuesta es: &quot;;
    print 6.  * 7;
    print &quot;\n&quot;; </code></pre>

</div>

<p>Tambien puedes imprimir una serie de valores separados por comas:</p>

<div class="programlisting">

<pre><code>    print &quot;The answer is &quot;, 6 * 7, &quot;.\n&quot;;</code></pre>

</div>

<p>Esto en realidad es una lista, pero aun no hemos visto listas.</p>

<h3>Interpolación de variables escalares en cadenas</h3>

<p><a name="Interpolación de variables escalares en cadenas"></p>

<p>Cuando un literal de cadena esta entre comillas dobles se puede usar interpolación. Esto significa que cada nombre de variable escalar en la cadena va a ser remplazado con su valor correspondiente. Por ejemplo:</p>

<div class="programlisting">

<pre><code>    $mpp = &quot;Ministerio del poder popular para&quot;; 
    $ministerio = &quot;$mpp Energ&iacute;a El&eacute;ctrica&quot;;

    $ministerio = $mpp . &#39; Energ&iacute;a El&eacute;ctrica&#39;; # Otra manera de hacelo</code></pre>

</div>

<p>Como pude ver en la ultima linea, puede hacer lo mismo sin usar las dobles comillas, pero usar las dobles comillas es la manera mas conveniente de hacerlo.</p>

<p>No use la interpolación si tiene solo una variable. Por ejemplo:</p>

<div class="programlisting">

<pre><code>    print &quot;$perl&quot;;      # Comillas innecesarias. 
    print $perl;        # Esto esta mejor.</code></pre>

</div>

<p>Para colocar un signo de dolar en una cadena entre dobles comillas, anteponga una barra invertida al signo de dolar, esto apaga el significado especial del sigil ($).</p>

<div class="programlisting">

<pre><code>    $fred = &#39;hello&#39;;
    print &quot;The name is \$fred.\n&quot;;      #imprime el signo $

    print &#39;The name is $fred&#39; . &quot;\n&quot;;   #Otra forma de hacerlo. </code></pre>

</div>

<p>Si usted quisiera usar una variable seguida por una constante de texto, puede tener problemas con la interpolación, en ese caso puede hacer lo siguiente: Envolver el nombre de la variable entre llaves.</p>

<div class="programlisting">

<pre><code>    $what = &quot;brontosaurus steak&quot;;
    $n = 3;
    print &quot;fred ate $n $whats.\n&quot;;                  #Esto no funciona
    print &quot;fred ate $n ${what}s.\n&quot;                 #Esto si funciona 
    print &quot;fred ate $n $what&quot; . &quot;s.\n&quot;              #Otra manera de hacerlo

    #Otra manera especialmente dificil de hacerlo 
    print &#39;fred ate &#39; . $n . &#39; &#39; . $what . &quot;s.\n&quot;; </code></pre>

</div>

<h3>Precedencia de los operadores y asociatividad</h3>

<p><a name="Precedencia de los operadores y asociatividad"></p>

<p>La prioridad en un operador determina que operaciones en un grupo complejo de operaciones ocurre primero. Por ejemplo en la expresión 2+3*4 ¿ que ocurre primero, la suma o la multiplicación ?. Si ocurre primero la suma tendremos 5*4 o 20. Pero si ocurre primero la multiplicación (como lo aprendimos en clases de matemáticas ) entonces tendremos 2 + 12 o 14. Afortunadamente, Perl escoge la definición matemática, realizando la multiplicación primero. Debido a esto decimos: <b>La multiplicación tiene una <code>Mayor prioridad</code> que la suma</b>.</p>

<p>Usted puede alterar el orden de prioridades usando los paréntesis. Cualquier cosa entre paréntesis es computado antes que los operadores fuera del paréntesis (justo como también lo aprendimos en clases de matemáticas). Entonces si usted quiere realizar una suma antes de una multiplicación tendría que hacer lo siguiente:</p>

<div class="programlisting">

<pre><code>    (2+3) * 4;</code></pre>

</div>

<p>Mientras la precedencia es simple para la adición y la multiplicación, puedes tener problemas cuando tengas una concatenación comparada con una potencia. La manera correcta de resolverlo es consultar la tabla oficial de operadores que se encuentra en el manual <b>perlop</b>.</p>

<div class="screen">

<pre><code>    $ perldoc perlop</code></pre>

</div>

<p>Normalmente las expresiones en Perl se evalúan de izquierda a derecha, aunque hay algunas excepciones que es necesario tener en cuenta. No se evalúan de izquierda a derecha los operadores de asignación y el operador de selección. Cuando una expresión tiene diversas posibilidades se aplica el orden de precedencia para establecer el calículo a realizar.</p>

<h3>Operadores de Comparación</h3>

<p><a name="Operadores de Comparación"></p>

<p>Para comparar números, Perl utiliza los operadores de comparación lógica que aprendimos en algebra: < <= == >= > !=. Cada uno de ellos retorna verdadero o falso. Debe usar >= en lugar de =>, ya que este ultimo es usado para otro propósito en Perl.</p>

<p>Para comparar cadenas de caracteres, Perl posee un grupo de operadores equivalentes de comparación de cadenas: <b>lt le eq ge gt ne</b>. Estos operadores comparan dos cadenas de caracteres carácter por carácter para ver si son la misma cosa o quien viene primero en el orden estándar de cadenas (En ASCII las mayúsculas van primero que las minúsculas.)</p>

<h4>Operadores de comparación numérica</h4>

<p><a name="Operadores de comparación numérica"></p>

<ul>

<li>== equality

<li>!= inequality

<li>< less than

<li>> greater than

<li><= less than or equal

<li>>= greater than or equal

</ul>

<h4>Operadores de comparación de cadenas</h4>

<p><a name="Operadores de comparación de cadenas"></p>

<ul>

<li>eq equality

<li>ne inequality

<li>lt less than

<li>gt greater than

<li>le less than or equal

<li>ge greater than or equal

</ul>

<p>Aquí tenemos un ejemplo usando operadores de comparación:</p>

<div class="programlisting">

<pre><code>   35   !=  30 + 5      # false 
   35   ==  35.0        # true
   &#39;35&#39; eq &#39;35.0        # false (comparaci&oacute;n de cadenas)
   &#39;fred&#39; lt &#39;barney&#39;   # false
   &#39;fred&#39; lt &#39;free&#39;     # true</code></pre>

</div>

<h2>La estructura de control IF</h2>

<p><a name="La estructura de control IF"></p>

<p>Una ves que comparas dos valores, probablemente quieras tomar una decisión basada en esa comparación. Como otros lenguajes similares, Perl tiene una estructura de control:</p>

<div class="programlisting">

<pre><code>    if ($nombre gt &#39;linus&#39;){
        print &quot;&#39;$nombre&#39; viene despues de &#39;linus&#39; en orden de cadenas\n&quot;;
    }</code></pre>

</div>

<p>Si requiere una opción alternativa, la palabra reservada <b>else</b> puede servirle para esto:</p>

<div class="programlisting">

<pre><code>    if ($nombre gt &#39;linus&#39;)
        print &quot;&#39;$nombre&#39; viene despues de &#39;linus&#39; en orden de cadenas\n&quot;;
    } else {
        print &quot;&#39;$nombre&#39; no viene despues de &#39;linus&#39;\n&quot;;
        print &quot;Es posible que sean la misma cadena\n&quot;;
    }</code></pre>

</div>

<h4>La verdad y la mentira en Perl</h4>

<p><a name="La verdad y la mentira en Perl"></p>

<p>El número 0, las cadenas <b>'0'</b> y <b>''</b>, la lista vacía <b>()</b>, y el valor <b>undef</b> son todos falsos en el contexto booleano. Cualquier otro valor es verdadero. La negación de un valor verdadero por los operadores <b>!</b> o <b>not</b> retornan un valor falso especial. Cuando se evalúa como una cadena, este valor es tratado como <b>''</b>, pero en el contexto numérico, es tratado como 0.</p>

<p>Puedes almacenar valores verdaderos y falsos de dos maneras, utilizando escalares, correspondientes a los dos contextos escalares. El contexto numérico y el contexto de cadena. Hay una cosa que debemos recordar: en el contexto numérico - 0 es falso y cualquier otro valor es verdadero; y en el contexto de cadenas, la cadena vacía '' es falsa y cualquier otro valor (incluyendo valores negativos) es verdadero.</p>

<p>El hecho de que cualquier valor distinto de cero es verdadero es especialmente útil en construcciones tales como bucles. Por ejemplo, este valor mantiene este bucle while pasando por <> y siempre retorna algo, incluso si el usuario introduce una línea vacía (en este caso, <> retorna un carácter de nueva linea):</p>

<div class="programlisting">

<pre><code>    while (&lt;&gt;) {
        print;
    }</code></pre>

</div>

<p>Los programadores a menudo se basan en el hecho de que cualquier cadena diferente de <b>cero (0)</b> o de <b>vació ('')</b> es verdadera. Se puede encontrar esto muy frecuentemente en el código, por ejemplo, verifico el valor a dividir para así evitar la división por cero.</p>

<div class="programlisting">

<pre><code>    if ($bt){
        $result - $top / $buttom; 
    } else {
        $result = 0;
    }</code></pre>

</div>

<p>Un punto para tomar en cuenta, sin embargo, es no probar contra valores falsos cuando se esta evaluando el valor <b>undef</b>. Algunas funciones retornan <b>undef</b> cuando no hay mas datos que leer, para evaluar esto, podemos usar la función <b>defined</b>. Por ejemplo:</p>

<p>Sin hacer uso de la función defined:</p>

<div class="programlisting">

<pre><code>    print &quot;Se obtuvo un valor&quot; if ($value = returnvalue($index)); </code></pre>

</div>

<p>Usando la función defined:</p>

<div class="programlisting">

<pre><code>    print &quot;Se obtuvo un valor&quot; if defined($value = returnvalue($index)); </code></pre>

</div>

<h2>Leer valores de la entrada estándar</h2>

<p><a name="Leer valores de la entrada estándar"></p>

<p>En este punto, se debe estar preguntando como obtener valores del teclado en un programa en Perl. Aquí vamos a ver una forma simple de hacer esto: usando el operador line-input <b>STDIN</b></p>

<p>Cada vez que usa STDIN en un lugar en el que un valor escalar es esperado, Perl lee la siguiente linea completa de la entrada estándar, hasta la próxima nueva linea. Ejemplo:</p>

<div class="programlisting">

<pre><code>    $line = &lt;STDIN&gt;;
    if ($line eq &quot;\n&quot;){
        print &quot;Esto es una linea en blanco !&quot;;
    } else {
        print &quot;La linea de entrada fue: $line&quot;; 
    }</code></pre>

</div>

<h3>El operador chomp</h3>

<p><a name="El operador chomp"></p>

<p>El operador chomp sirve para quitar el retorno de carro que viene con la linea de texto leída desde la entrada estándar. Ejemplo</p>

<div class="programlisting">

<pre><code>    $text = &quot;una linea de texto \n&quot;; # suponiendo que viene de &lt;STDIN&gt;
    chomp($text); # Quita el caracter de nueva linea.

    chomp($text = &lt;STDIN&gt;);     # Otra forma de hacerlo.</code></pre>

</div>

<h2>La estructura de control while</h2>

<p><a name="La estructura de control while"></p>

<p>Al igual que otros lenguajes, Perl posee un número de estructuras de bucle. El bucle while repite un bloque de codigo mientras la condición sea verdadera:</p>

<div class="programlisting">

<pre><code>    $count = 0; 
    while ($count &lt; 10){
        $count += 2;
        print &quot;count is now $count\n&quot;; # obtiene los valores 2 4 6 8 10
    }</code></pre>

</div>

<h2>El valor undef</h2>

<p><a name="El valor undef"></p>

<p>El valor definido <b>undef</b> se puede utilizar para identificar determinadas condiciones de error y la existencia o no de información de matrices o variables hash. El valor undef se utiliza normalmente como valor de retorno de una función que, de otra manera, proporcionaría un valor de 0, que podría ser autentico. Por ejemplo, el valor de un puntero de archivos en un descriptor de archivos podría ser cero, por lo tanto que la función <b>tell</b> genera el valor <b>undef</b> si el valor no se puede determinar.</p>

<p>¿ Que pasaría si usted usa una variable escalar antes de darle un valor ?, pues nada serio, y definitivamente nada fatal. Las variables tienen el valor especial <b>undef</b> antes de la primera asignación.</p>

<p>Como <b>undef</b> automáticamente actúa como el cero (0) cuando se usa en el contexto numérico, es fácil hacer un acumulador numérico que inicie vacío, por ejemplo:</p>

<pre><code> =begin programlisting
 
    $n = 1;
    while ($n &lt; 10){
        $sum += $n;
        $n += 2; 
    }
    print &quot;El total fue: $sum \n&quot;
 
 =end programlisting
 </code></pre>

<p>Supongamos que usted ha decidido usar la función sysread para leer el texto de unos archivos y pasarlo a la aplicación que esta escribiendo en Perl. Se sabe que sysread retorna un escalar indicando cuantos bytes se están leyendo. Pero ¿que pasa al final de archivo?, ¿que clase de valor retornará sysread?, ¿porque la función retorna un escalar, debe ser un número o un string, cierto?</p>

<p>Pues no, aparte de números y strings, las variables escalares pueden incluso mantener el valor indefinido de Perl, llamado como ya dijimos anteriormente <b>undef</b>. Este valor es retornado por algunas funciones, y puedes comprobarlo usando una función llamada <b>defined</b>. Si examinas el valor <b>undef</b> directamente, este es interpretado como un cero (0) en un contexto numérico y como un string vació <b>""</b> en el contexto de cadenas de caracteres. También puedes asignar a las variables el valor undef usando la función <b>undef</b>. Este ejemplo da a la variable <b>$variable1</b> el valor 5:</p>

<div class="programlisting">

<pre><code>    $variable = 5;</code></pre>

</div>

<p>Y usando la función <b>undef</b> sobre la variable, se puede convertir en variable no definida.</p>

<div class="programlisting">

<pre><code>    $variable1 = 5;
    undef $variable1;</code></pre>

</div>

<p>Ahora, puedes probar si $variable1 esta definida usando la función <b>defined</b>:</p>

<div class="programlisting">

<pre><code>    $variable1 = 5;
    undef $variable1;
    
    if (defined $variable1){
        print &quot;\$variable1 esta definida. \n&quot;;
    } else {
        print &quot;\$variable1 no esta definida \n&quot;;
    }</code></pre>

</div>

<p>En este caso, este código muestra el siguiente mensaje:</p>

<div class="screen">

<pre><code>    $variable1 no esta definida</code></pre>

</div>

<p>Varios operadores retornan undef cuando los argumentos están fuera del rango esperado o no tienen sentido.</p>

<p>Cuando se tienen activadas las advertencias en Perl, generalmente Perl advierte sobre el uso no adecuado del valor undef, por ejemplo, si intenta copiar el valor undef de una variable a otra, esto no va a causar ningún problema, pero si intenta imprimir un valor undef, generalmente va a causar una advertencia.</p>

<p>Resumiendo, las variables no definidas que poseen el valor <b>undef</b>, en contexto escalar es interpretado como cero (0) y en contexto de cadena de caracteres es interpretado como vacío <b>""</b>.</p>

<h2>Ejercicios</h2>

<p><a name="ejercicios_01"></p>

<ul>

<li>1. Escriba un programa que compute la circunferencia de un circulo con radio de 12.5 la circunferencia es dos veces PI, (aproximadamente 2 veces 3.141592654)

<li>2. Modifique el programa anterior para que acepte el valor del radio desde la entrada estándar. Si el usuario introduce 12.5 debe obtener el mismo valor que el primer ejercicio.

<li>3. Modifique el programa del ejercicio anterior, de modo que si el usuario introduce un numero menor que cero, la circunferencia reportada sea cero en lugar de negativo.

<li>4. Escriba un programa que pida dos números (en lineas separadas en el input) e imprima el producto de los dos números multiplicados.

<li>5. Escriba un programa que pida una cadena y un número (en lineas separadas en el input) e imprima en la salida la cadena repetida el numero de veces que indica el numero que introdujo el usuario. (Consejo: use el operador x)

</ul>

</div>

</body>
</html>

