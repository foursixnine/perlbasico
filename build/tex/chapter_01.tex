\chapter{Datos Escalares}

\section*{Números}

Aunque los números y las cadenas con frecuencia se pueden tratar como escalares, es útil observarlos inicialmente por separado. Vamos a ver primero los números y luego pasamos a las cadenas.

\subsection*{Todos los números internamente tienen el mismo formato}

Todos los números internamente tienen el mismo formato

Como vera en los próximos párrafos, se puede especif\mbox{}icar tanto números enteros (como 255 o 2001) y números de coma f\mbox{}lotante (números reales con puntos decimales, como 3.1416 o 1.35 x 1025). Pero internamente, Perl calcula valores punto f\mbox{}lotantes de doble precisión. Esto signif\mbox{}ica que no hay valores enteros internamente en Perl. Una constante entera en Perl es tratada como su valor equivalente en coma f\mbox{}lotante. Probablemente no se dará cuenta de la conversión, deje de buscar las distintas operaciones con enteros (en oposición a las operaciones de punto f\mbox{}lotante), porque simplemente no existen. \footnote{Existe un pragma llamado Integer, que permite realizar operaciones con enteros en lugar de punto f\mbox{}lotante, pero es otra cosa, y no es de lo que estamos hablando en este punto}

\subsection*{Literales de punto f\mbox{}lotante}

Literales de punto f\mbox{}lotante

Un literal es la forma en que un valor se representa en el código fuente en Perl. Un literal no es el resultado de una operación de calculo o de una operación de I/O. Es datos escritos directamente en el código fuente.

Un literal de coma f\mbox{}lotante, ya debe serle familiar. Números con y sin punto f\mbox{}lotante también son permitidos (incluyendo el pref\mbox{}ijo opcional mas y menos), y de remate el indicador de notación exponencial E.

\begin{verbatim}
    1.25 
    255.000 
    255.0 
    7.25e45 
    âˆ’6.5e24
    âˆ’12e-24 
    âˆ’1.2E-23\end{verbatim}
\subsection*{Literales Enteros}

Literales Enteros

Los literales enteros son muy sencillos de expresar, ejemplo:

\begin{verbatim}
    0
    2001
    -40
    42
    469
    61298040283768\end{verbatim}
El último número es un poco difícil de leer, Perl permite underscores para mayor claridad con los literales enteros, de modo que puede escribir ese último número de la siguiente manera:

\begin{verbatim}
    61_298_040_283_768\end{verbatim}
Este es el mismo número, solo que se ve un poco diferente para nosotros, los humanos. Podría pensar que se deberían usar comas en lugar de esto, pero las comas ya tienen un propósito mas importante en Perl.

\subsection*{Literales enteros no decimales}

Literales enteros no decimales

Como en otros lenguajes de programación Perl permite especif\mbox{}icar números que no son de base 10 (decimal). Literales de base 8 (Octal) deben comenzar con un 0, los literales de base 16 (Hexadecimal) deben comenzar con 0x y los literales binarios (base 2) deben comenzar con 0b.* Los dígitos hexadecimales de la A hasta la F, representan los valores de los dígitos convencionales del 10 al 15.

\begin{verbatim}
    0377        # 377 octal, same as 255 decimal
    0xff        # FF hex, also 255 decimal
    0b11111111 # also 255 decimal\end{verbatim}
Estos tres números, son la misma cosa para Perl, aunque para nosotros, los humanos tengan un aspecto diferente. No hay ninguna diferencia con respecto a Perl en escribir 255.000 o 0xFF. Así que elija la representación que tenga mas sentido para usted.

\subsection*{Operadores numéricos}

Operadores numéricos

Perl provee operadores típicos de suma, resta, multiplicación y división. Ejemplo:

\begin{verbatim}
    2 + 3       # 2 plus 3, or 5
    5.1 âˆ’ 2.4 # 5.1 minus 2.4, or 2.7
    3 * 12      # 3 times 12 = 36
    14 / 2      # 14 divided by 2, or 7\end{verbatim}
Perl también soporta el operador de módulo (\%). El valor de la expresión 10 \% 3 es el resto de la división de 10 entre 3, que es 1. Adicionalmente Perl provee el valor por potenciación tipo FORTRAN (**) que todos anhelaron en C y Pascal. El operador esta representado por el doble asterisco (**), entonces podemos tener 2 ** 3 que es dos elevado a la tercera potencia. \footnote{El resultado de una operación de módulo cuando uno o mas valores negativos están involucrados puede variar dependiendo de la implementación de Perl, tenga cuidado}

\section*{Strings o Cadenas de Caracteres}

Strings o Cadenas de Caracteres

Las cadenas son secuencias de caracteres (como hola). Las cadenas pueden contener cualquier combinación de los caracteres. La cadena mas corta posible no tiene caracteres. La cadena mas larga llena toda la memoria, aunque no podría hacer mucho con esto.

Una cadena típica, son secuencias de letras, números y signos de puntación contenidos en el rango ASCII 32 al 126.

Como los números, las cadenas tienen una representación literal, que es la forma en que se representa una cadena en un programa en Perl. Los literales de cadenas vienen en dos formatos diferentes. Cadenas encerradas en comillas simples y cadenas encerradas en comillas dobles.

\subsection*{Cadenas en comillas simples}

Cadenas en comillas simples

Las comillas simples, no son parte de la cadena, están allí para que Perl identif\mbox{}ique el principio y el f\mbox{}inal de la cadena. Cualquier carácter que no sea una comilla simple o una barra invertida entre las comillas va a estar representado a si mismo en la cadena. Ejemplo:

\begin{verbatim}
    'fred'          # those four characters: f, r, e, and d
    'barney'    # those six characters
    ''          # the null string (no characters)
    'Esto\'D evita que el apostrofe rompa la cadena'
    'El último caracter de esta linea es un backslash \\'
    'Hola \n'   # Hola seguido por un backslash seguido por una n
    'Hola 
    Mundo '     # Hola, salto de linea, mundo (11 caracteres en total) 
    '\'\\'      # Comilla simple seguida por un backslash. 
=end programlisting\end{verbatim}
Note que \\n dentro de comillas simples no es interpretado como un salto de linea.

\subsection*{Cadenas en comillas dobles}

Cadenas en comillas dobles

De igual manera, es una cadena de caracteres, solo que en comillas dobles, y ahora la barra invertida tiene el poder especial de especif\mbox{}icar caracteres de control, o cualquier caracteres a través de representaciones octales y hexadecimales. Estas son algunas de las cadenas entre comillas dobles:

\begin{verbatim}
    "larry"         # es lo mismo que 'larry'
    "hello world\n" # hello world y un salto de linea
    "El ultimo caracter de esta linea es una comilla doble: \""
    "Cafe \t coca"  # Cafe,  tabulador,  coca.\end{verbatim}
Puede ver una tabla de las secuencias de escape disponibles en Perl, en el manual \textbf{perlrebackslash}

Otra caracteristica interesante de las cadenas de caracteres en doble comillas es la interpolación.

\subsection*{Operadores de cadenas de caracteres}

Operadores de cadenas de caracteres

Los valores de cadenas se pueden concatenar con el operador \textbf{.}, esto no altera la cadena, simplemente la concatena, así que el resultado es una cadena mas, disponible para una operación o asignar a una variable. Ejemplo:

\begin{verbatim}
    "Hello" . "World"           # HelloWorld
    "Hello" . ' ' . "World"     # Hello World
    "Hello World" .  "\n"       # Hello World\n\end{verbatim}
Un operador especial de cadenas, es el operador de repetición, que consiste en la letra minúscula x. Este operador toma a su operando de la izquierda (una cadena) y hace tantas copias concatenadas de la misma como indica su operando de la izquierda (un número). Ejemplo:

\begin{verbatim}
    "perl"x3        # es perlperlperl
    "perl"x(3+5)    # es perlperlperlperlperlperlperlperl
    5x4             # es 5555\end{verbatim}
\subsection*{Conversión automática entre números y cadenas}

Conversión automática entre números y cadenas

En su mayor parte, Perl convierte entre números y cadenas según sea necesario. ¿ Como saber que necesita ? todo depende del operador que este usando en el valor escalar. Si el operador espera un número (como el operador +), Perl va a ver el valor como un número. Si el operador espera una cadena (como . o x) entonces Perl va a ver el valor como una cadena. Así que no tiene que preocuparse por la diferencia entre los números y las cadenas, solo tiene que preocuparse por los operadores adecuados y perl hará todo el trabajo. Ejemplos:

\begin{verbatim}
    "12" * 3        # es 36
    "Z" . 5 * 7     # es Z35\end{verbatim}
\section*{Warnings o Advertencias}

Warnings o Advertencias

Perl puede avisarle cuando vea algo sospechoso en su programa. Para correr un programa con las advertencias activadas debe usar la opción \textbf{-w} en la linea de comandos.

Si pref\mbox{}iere tener siempre activadas las advertencias, entonces puede indicarlo en la linea \#!

\begin{verbatim}
    #!/usr/bin/perl -w\end{verbatim}
A partir de Perl 5.6 en adelante, puedes activar las advertencias a través del pargma \textbf{warnings}

\begin{verbatim}
    #!/usr/bin/perl
    use warnings; \end{verbatim}
Ahora, Perl va a advertirle cuando use '12perl42' como si se tratara de un número.

Por su puesto, las advertencias son para los programadores, no para los usuarios f\mbox{}inales. Si las advertencias no van a ser vistas por un programador, pues probablemente sean inútiles.

Las advertencias no van a cambiar el funcionamiento de su programa, salvo que ahora Perl se queja de vez en cuando. Si recibe un mensaje que no entiende, se puede conseguir una mayor descripción con el pragma \textbf{diagnostics}. La página del manual \textbf{perldiag} contiene los tipos de advertencias.

\begin{verbatim}
    #!/usr/bin/perl 
    use diagnostics;\end{verbatim}
\section*{Variables Escalares}

Variables Escalares

Una variable es un nombre para un contenedor que posee uno o mas valores. El nombre de la variable va a ser el mismo durante la ejecución del programa, pero el contenido puede variar durante la ejecución del mismo.

Una variable escalar, almacena un valor escalar simple. El nombre de una variable escalar comienza con el signo dolar (\$)\footnote{Esto es llamado sígil en lengua Perl} seguido por algo que vamos a llamar identif\mbox{}icador Perl: una letra o un guion bajo, y luego posiblemente, mas letras o dígitos o guiones bajos. Otra forma de verlo, es que esta formado por caracteres alfanuméricos y guiones, pero no puede comenzar con un dígito. Se distingue entre mayúsculas y minúsculas, la variable \$perl es distinta de la variable \$Perl y \$PERL. Y todas las letras, signos y guiones bajos son signif\mbox{}icativos. Por lo que:

\begin{verbatim}
    $una_variable_muy_muy_larga_que_termina_en_1\end{verbatim}
Es diferente a

\begin{verbatim}
    $una_variable_muy_muy_larga_que_termina_en_2 \end{verbatim}
Las variables escalares pueden ser referenciadas usando un \& luego del sígil \$, con lo que quedaría \$\&.

\subsection*{Colocando nombres adecuados a las variables}

Colocando nombres adecuados a las variables

Los nombres cortos en las variables, son útiles cuando la vida de la variable es de apenas 3 o 4 lineas, pero cuando la variable va a tener vida durante todo el programa o la función, vale la pena colocar un nombre que describa fácilmente el contenido de la variable.

Del mismo modo, el uso de guion abajo, puede ser útil para separa las palabras, esto hace un nombre de variable fácil de leer y entender, sobre todo si se trabaja con programadores cuya lengua materna es diferente a la suya.

La mayoria de las variables en Perl van a estar escritas en minúsculas, las variables en donde todas las letras son mayúsculas, normalmente son variables especiales como \$ARGV.

Cuando el nombre de la variable tiene mas de una palabra, alguna gente pref\mbox{}iere usar guiones bajos (como \$esta\_es\_una\_variable) y otros pref\mbox{}ieren usar \$estaEsUnaVariable. Solo sea consistente.

\subsection*{Asignación de variables escalares}

Asignación de variables escalares

La operación mas common en las variables escalares es la asignación, pues es la forma de darle valor a una variable. El operador de asignación en Perl es el signo igual (=), el nombre de la variable va a la izquierda y el valor de la variable a la derecha. Ejemplos:

\begin{verbatim}
    $perl       = 17; 
    $prueba     = 'hola';
    $prueba     = $perl + 3;
    $prueba     = $prueba * 2;
    \end{verbatim}
\subsection*{Operadores de asignación binarios}

Operadores de asignación binarios

Expresiones como \$perl = \$perl + 5, aparecen frecuentemente en el código, como una manera rápida de alterar el valor de la variable. Hay una manera mas corta de hacer esto, usando el operador de asignación binario. Casi todos los operadores binarios que computan un valor, tienen un operador de asignación binario. Ejempo, las siguientes dos lineas son equivalentes:

\begin{verbatim}
    $perl = $perl + 5;      #sin el operador de asignación binario
    $perl += 5;             #con el operador de asignación binario\end{verbatim}
Tambien es equivalente:

\begin{verbatim}
    $perl = $perl * 5;
    $perl *= 5;\end{verbatim}
Para cada caso, los operadores alteran el valor correspondiente de la variable, colocando el valor resultante de la operación.

Otro operador de asignación común biene dado por el operador de concatenación de cadenas (.) con lo que obtenemos el operador (.=)

\begin{verbatim}
    $str = $str . " ";
    $str .= " ";\end{verbatim}
Casi todos los operadores binarios son válidos, por ejemplo puede usar el operador binario de potencia de la siguiente manera:

\begin{verbatim}
    $numero **= 3;\end{verbatim}
\section*{Salida con Print}

Salida con Print

Es una buena idea que sus programas produzcan algún tipo de salidas por pantalla, de lo contrario, la gente pensara que el programa no esta haciendo nada.

El operador Print() hace esto posible, este toma un argumento escalar y lo pone sin embellesimiento en la salida estandar. Ejemplo:

\begin{verbatim}
    print "hello world\n";      # imprime hello world y un salto de linea.
    print "Y la respuesta es: ";
    print 6.  * 7;
    print "\n"; \end{verbatim}
Tambien puedes imprimir una serie de valores separados por comas:

\begin{verbatim}
    print "The answer is ", 6 * 7, ".\n";\end{verbatim}
Esto en realidad es una lista, pero aun no hemos visto listas.

\subsection*{Interpolación de variables escalares en cadenas}

Interpolación de variables escalares en cadenas

Cuando un literal de cadena esta entre comillas dobles se puede usar interpolación. Esto signif\mbox{}ica que cada nombre de variable escalar en la cadena va a ser remplazado con su valor correspondiente. Por ejemplo:

\begin{verbatim}
    $mpp = "Ministerio del poder popular para"; 
    $ministerio = "$mpp Energía Eléctrica";

    $ministerio = $mpp . ' Energía Eléctrica'; # Otra manera de hacelo\end{verbatim}
Como pude ver en la ultima linea, puede hacer lo mismo sin usar las dobles comillas, pero usar las dobles comillas es la manera mas conveniente de hacerlo.

No use la interpolación si tiene solo una variable. Por ejemplo:

\begin{verbatim}
    print "$perl";      # Comillas innecesarias. 
    print $perl;        # Esto esta mejor.\end{verbatim}
Para colocar un signo de dolar en una cadena entre dobles comillas, anteponga una barra invertida al signo de dolar, esto apaga el signif\mbox{}icado especial del sigil (\$).

\begin{verbatim}
    $fred = 'hello';
    print "The name is \$fred.\n";      #imprime el signo $

    print 'The name is $fred' . "\n";   #Otra forma de hacerlo. \end{verbatim}
Si usted quisiera usar una variable seguida por una constante de texto, puede tener problemas con la interpolación, en ese caso puede hacer lo siguiente: Envolver el nombre de la variable entre llaves.

\begin{verbatim}
    $what = "brontosaurus steak";
    $n = 3;
    print "fred ate $n $whats.\n";                  #Esto no funciona
    print "fred ate $n ${what}s.\n"                 #Esto si funciona 
    print "fred ate $n $what" . "s.\n"              #Otra manera de hacerlo

    #Otra manera especialmente dificil de hacerlo 
    print 'fred ate ' . $n . ' ' . $what . "s.\n"; \end{verbatim}
\subsection*{Precedencia de los operadores y asociatividad}

Precedencia de los operadores y asociatividad

La prioridad en un operador determina que operaciones en un grupo complejo de operaciones ocurre primero. Por ejemplo en la expresión 2+3*4 ¿ que ocurre primero, la suma o la multiplicación ?. Si ocurre primero la suma tendremos 5*4 o 20. Pero si ocurre primero la multiplicación (como lo aprendimos en clases de matemáticas ) entonces tendremos 2 + 12 o 14. Afortunadamente, Perl escoge la def\mbox{}inición matemática, realizando la multiplicación primero. Debido a esto decimos: \textbf{La multiplicación tiene una \texttt{Mayor prioridad} que la suma}.

Usted puede alterar el orden de prioridades usando los paréntesis. Cualquier cosa entre paréntesis es computado antes que los operadores fuera del paréntesis (justo como también lo aprendimos en clases de matemáticas). Entonces si usted quiere realizar una suma antes de una multiplicación tendría que hacer lo siguiente:

\begin{verbatim}
    (2+3) * 4;\end{verbatim}
Mientras la precedencia es simple para la adición y la multiplicación, puedes tener problemas cuando tengas una concatenación comparada con una potencia. La manera correcta de resolverlo es consultar la tabla of\mbox{}icial de operadores que se encuentra en el manual \textbf{perlop}.

Normalmente las expresiones en Perl se evalúan de izquierda a derecha, aunque hay algunas excepciones que es necesario tener en cuenta. No se evalúan de izquierda a derecha los operadores de asignación y el operador de selección. Cuando una expresión tiene diversas posibilidades se aplica el orden de precedencia para establecer el calículo a realizar.

\subsection*{Operadores de Comparación}

Operadores de Comparación

Para comparar números, Perl utiliza los operadores de comparación lógica que aprendimos en algebra: < <= == >= > !=. Cada uno de ellos retorna verdadero o falso. Debe usar >= en lugar de =>, ya que este ultimo es usado para otro propósito en Perl.

Para comparar cadenas de caracteres, Perl posee un grupo de operadores equivalentes de comparación de cadenas: \textbf{lt le eq ge gt ne}. Estos operadores comparan dos cadenas de caracteres carácter por carácter para ver si son la misma cosa o quien viene primero en el orden estándar de cadenas (En ASCII las mayúsculas van primero que las minúsculas.)

\subsubsection*{Operadores de comparación numérica}

Operadores de comparación numérica

\flushleft
\begin{description}

\item[] == equality

\item[] != inequality

\item[] < less than

\item[] > greater than

\item[] <= less than or equal

\item[] >= greater than or equal

\end{description}

\subsubsection*{Operadores de comparación de cadenas}

Operadores de comparación de cadenas

\flushleft
\begin{description}

\item[] eq equality

\item[] ne inequality

\item[] lt less than

\item[] gt greater than

\item[] le less than or equal

\item[] ge greater than or equal

\end{description}

Aquí tenemos un ejemplo usando operadores de comparación:

\begin{verbatim}
   35   !=  30 + 5      # false 
   35   ==  35.0        # true
   '35' eq '35.0        # false (comparación de cadenas)
   'fred' lt 'barney'   # false
   'fred' lt 'free'     # true\end{verbatim}
\section*{La estructura de control IF}

La estructura de control IF

Una ves que comparas dos valores, probablemente quieras tomar una decisión basada en esa comparación. Como otros lenguajes similares, Perl tiene una estructura de control:

\begin{verbatim}
    if ($nombre gt 'linus'){
        print "'$nombre' viene despues de 'linus' en orden de cadenas\n";
    }\end{verbatim}
Si requiere una opción alternativa, la palabra reservada \textbf{else} puede servirle para esto:

\begin{verbatim}
    if ($nombre gt 'linus')
        print "'$nombre' viene despues de 'linus' en orden de cadenas\n";
    } else {
        print "'$nombre' no viene despues de 'linus'\n";
        print "Es posible que sean la misma cadena\n";
    }\end{verbatim}
\subsubsection*{La verdad y la mentira en Perl}

La verdad y la mentira en Perl

El número 0, las cadenas \textbf{'0'} y \textbf{''}, la lista vacía \textbf{()}, y el valor \textbf{undef} son todos falsos en el contexto booleano. Cualquier otro valor es verdadero. La negación de un valor verdadero por los operadores \textbf{!} o \textbf{not} retornan un valor falso especial. Cuando se evalúa como una cadena, este valor es tratado como \textbf{''}, pero en el contexto numérico, es tratado como 0.

Puedes almacenar valores verdaderos y falsos de dos maneras, utilizando escalares, correspondientes a los dos contextos escalares. El contexto numérico y el contexto de cadena. Hay una cosa que debemos recordar: en el contexto numérico - 0 es falso y cualquier otro valor es verdadero; y en el contexto de cadenas, la cadena vacía '' es falsa y cualquier otro valor (incluyendo valores negativos) es verdadero.

El hecho de que cualquier valor distinto de cero es verdadero es especialmente útil en construcciones tales como bucles. Por ejemplo, este valor mantiene este bucle while pasando por <> y siempre retorna algo, incluso si el usuario introduce una línea vacía (en este caso, <> retorna un carácter de nueva linea):

\begin{verbatim}
    while (<>) {
        print;
    }\end{verbatim}
Los programadores a menudo se basan en el hecho de que cualquier cadena diferente de \textbf{cero (0)} o de \textbf{vació ('')} es verdadera. Se puede encontrar esto muy frecuentemente en el código, por ejemplo, verif\mbox{}ico el valor a dividir para así evitar la división por cero.

\begin{verbatim}
    if ($bt){
        $result - $top / $buttom; 
    } else {
        $result = 0;
    }\end{verbatim}
Un punto para tomar en cuenta, sin embargo, es no probar contra valores falsos cuando se esta evaluando el valor \textbf{undef}. Algunas funciones retornan \textbf{undef} cuando no hay mas datos que leer, para evaluar esto, podemos usar la función \textbf{def\mbox{}ined}. Por ejemplo:

Sin hacer uso de la función def\mbox{}ined:

\begin{verbatim}
    print "Se obtuvo un valor" if ($value = returnvalue($index)); \end{verbatim}
Usando la función def\mbox{}ined:

\begin{verbatim}
    print "Se obtuvo un valor" if defined($value = returnvalue($index)); \end{verbatim}
\section*{Leer valores de la entrada estándar}

Leer valores de la entrada estándar

En este punto, se debe estar preguntando como obtener valores del teclado en un programa en Perl. Aquí vamos a ver una forma simple de hacer esto: usando el operador line-input \textbf{STDIN}

Cada vez que usa STDIN en un lugar en el que un valor escalar es esperado, Perl lee la siguiente linea completa de la entrada estándar, hasta la próxima nueva linea. Ejemplo:

\begin{verbatim}
    $line = <STDIN>;
    if ($line eq "\n"){
        print "Esto es una linea en blanco !";
    } else {
        print "La linea de entrada fue: $line"; 
    }\end{verbatim}
\subsection*{El operador chomp}

El operador chomp

El operador chomp sirve para quitar el retorno de carro que viene con la linea de texto leída desde la entrada estándar. Ejemplo

\begin{verbatim}
    $text = "una linea de texto \n"; # suponiendo que viene de <STDIN>
    chomp($text); # Quita el caracter de nueva linea.

    chomp($text = <STDIN>);     # Otra forma de hacerlo.\end{verbatim}
\section*{La estructura de control while}

La estructura de control while

Al igual que otros lenguajes, Perl posee un número de estructuras de bucle. El bucle while repite un bloque de codigo mientras la condición sea verdadera:

\begin{verbatim}
    $count = 0; 
    while ($count < 10){
        $count += 2;
        print "count is now $count\n"; # obtiene los valores 2 4 6 8 10
    }\end{verbatim}
\section*{El valor undef}

El valor undef

El valor def\mbox{}inido \textbf{undef} se puede utilizar para identif\mbox{}icar determinadas condiciones de error y la existencia o no de información de matrices o variables hash. El valor undef se utiliza normalmente como valor de retorno de una función que, de otra manera, proporcionaría un valor de 0, que podría ser autentico. Por ejemplo, el valor de un puntero de archivos en un descriptor de archivos podría ser cero, por lo tanto que la función \textbf{tell} genera el valor \textbf{undef} si el valor no se puede determinar.

¿ Que pasaría si usted usa una variable escalar antes de darle un valor ?, pues nada serio, y def\mbox{}initivamente nada fatal. Las variables tienen el valor especial \textbf{undef} antes de la primera asignación.

Como \textbf{undef} automáticamente actúa como el cero (0) cuando se usa en el contexto numérico, es fácil hacer un acumulador numérico que inicie vacío, por ejemplo:

\begin{verbatim}
 =begin programlisting
 
    $n = 1;
    while ($n < 10){
        $sum += $n;
        $n += 2; 
    }
    print "El total fue: $sum \n"
 
 =end programlisting
 \end{verbatim}
Supongamos que usted ha decidido usar la función sysread para leer el texto de unos archivos y pasarlo a la aplicación que esta escribiendo en Perl. Se sabe que sysread retorna un escalar indicando cuantos bytes se están leyendo. Pero ¿que pasa al f\mbox{}inal de archivo?, ¿que clase de valor retornará sysread?, ¿porque la función retorna un escalar, debe ser un número o un string, cierto?

Pues no, aparte de números y strings, las variables escalares pueden incluso mantener el valor indef\mbox{}inido de Perl, llamado como ya dijimos anteriormente \textbf{undef}. Este valor es retornado por algunas funciones, y puedes comprobarlo usando una función llamada \textbf{def\mbox{}ined}. Si examinas el valor \textbf{undef} directamente, este es interpretado como un cero (0) en un contexto numérico y como un string vació \textbf{``''} en el contexto de cadenas de caracteres. También puedes asignar a las variables el valor undef usando la función \textbf{undef}. Este ejemplo da a la variable \textbf{\$variable1} el valor 5:

\begin{verbatim}
    $variable = 5;\end{verbatim}
Y usando la función \textbf{undef} sobre la variable, se puede convertir en variable no def\mbox{}inida.

\begin{verbatim}
    $variable1 = 5;
    undef $variable1;\end{verbatim}
Ahora, puedes probar si \$variable1 esta def\mbox{}inida usando la función \textbf{def\mbox{}ined}:

\begin{verbatim}
    $variable1 = 5;
    undef $variable1;
    
    if (defined $variable1){
        print "\$variable1 esta definida. \n";
    } else {
        print "\$variable1 no esta definida \n";
    }\end{verbatim}
En este caso, este código muestra el siguiente mensaje:

Varios operadores retornan undef cuando los argumentos están fuera del rango esperado o no tienen sentido.

Cuando se tienen activadas las advertencias en Perl, generalmente Perl advierte sobre el uso no adecuado del valor undef, por ejemplo, si intenta copiar el valor undef de una variable a otra, esto no va a causar ningún problema, pero si intenta imprimir un valor undef, generalmente va a causar una advertencia.

Resumiendo, las variables no def\mbox{}inidas que poseen el valor \textbf{undef}, en contexto escalar es interpretado como cero (0) y en contexto de cadena de caracteres es interpretado como vacío \textbf{``''}.

\section*{Ejercicios}

Ejercicios

\flushleft
\begin{description}

\item[] 1. Escriba un programa que compute la circunferencia de un circulo con radio de 12.5 la circunferencia es dos veces PI, (aproximadamente 2 veces 3.141592654)

\item[] 2. Modif\mbox{}ique el programa anterior para que acepte el valor del radio desde la entrada estándar. Si el usuario introduce 12.5 debe obtener el mismo valor que el primer ejercicio.

\item[] 3. Modif\mbox{}ique el programa del ejercicio anterior, de modo que si el usuario introduce un numero menor que cero, la circunferencia reportada sea cero en lugar de negativo.

\item[] 4. Escriba un programa que pida dos números (en lineas separadas en el input) e imprima el producto de los dos números multiplicados.

\item[] 5. Escriba un programa que pida una cadena y un número (en lineas separadas en el input) e imprima en la salida la cadena repetida el numero de veces que indica el numero que introdujo el usuario. (Consejo: use el operador x)

\end{description}

