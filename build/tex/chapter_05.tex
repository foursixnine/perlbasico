\chapter{Hashes}

En este capítulo, usted va a ver una de las características que hacen de Perl uno de los mejores lenguajes del mundo de programación imperativa: Hashes \footnote{En los viejos tiempos, los llamábamos ``arrays asociativos''. Pero la comunidad de Perl decidió por 1995 que eran muchas letras al escribirlas y muchas silabas al pronunciarlo, entones cambiaron el nombre a ``Hashes''}

Aunque los Hashes son una útil y poderosa característica, es probable que hallas usado otros lenguajes poderosos durante años sin haber escuchado sobre los Hashes. Pero usted va a usar hashes en casi todos los programas en Perl que escriba de ahora en adelante.

\section{¿ Que es un Hash ?}

Un hash es una estructura de datos, no es muy diferente a un array, que puede almacenar cualquier número de valores y obtenerlos cuando quiera. Pero en lugar de indexar los valores por un numero, como lo hacemos con los arrays, vamos a indexar los valores por un nombre. Esto signif\mbox{}ica, que los indices (a los que vamos a llamar llaves) no son números, en lugar de esto vamos a usar cadenas arbitrarias únicas.

Primero que todo, las llaves son cadenas de caracteres, entonces, en lugar de usar el numero 3 para obtener un elemento de un array, vamos a acceder al elemento del hash llamado \texttt{wilma}.

Estas llaves, son cadenas arbitrarias - usted puede usar cualquier expresión de cadena para la llave de un hash. Y estas son cadenas únicas - de igual manera que en un array tenemos un único elemento numérico 3, aquí vamos a tener un único elemento del hash llamado \texttt{wilma}.

Otra forma de pensar en un hash, es compararlo con un barril de datos, donde cada pieza de datos tiene una etiqueta. Tu puedes llegar al barril y sacar una etiqueta y mirar que pieza de datos contiene. Pero no va a ser el ``primer'' elemento del barril. En un array, comenzamos desde el elemento 0, seguido del elemento 1, el elemento 2 y así. Pero en un hash, no hay un orden f\mbox{}ijo, no hay un primer elemento. Es solo una colección de pares llave-valor.

\begin{figure}[!h]
\caption{Hashes}
\begin{center}
\label{hashes}


\includegraphics{hashes}

\end{center}
\end{figure}
\begin{figure}[!h]
\caption{Hashes como Barril}
\begin{center}
\label{hashes}


\includegraphics{barril}

\end{center}
\end{figure}
Las llaves y los valores son un conjunto de valores escalares ordinarios, pero las llaves son siempre convertidas a cadenas. Entonces, si usas la expresión numérica \texttt{50/20} como una llave, esto se va a convertir en una cadena de tres caracteres ``2.5''.

Como es usual en Perl,"no existen los límites innecesarios'', esto también aplica a un hash, un hash puede ser de cualquier tamaño, desde un hash vacío con cero pares llave-valor, hasta cualquier cantidad de valores con los que pueda llena su memoria.

Algunas implementaciones de hashes (como originalmente era en el lenguaje awk) cuando los hashes son de gran tamaño tienden a ser lentos. Este no es el caso en Perl, en Perl es un algoritmo ef\mbox{}iciente, bueno y escalable. Entonces, si un hash tiene un solo árbol de pares llave-valor, es muy rápido ``buscar en el barril'' y tomar uno de esos valores. Si un hash tiene tres millones de pares clave-valor, debe ser igual de rápido tomar un valor. No se asuste, los hashs grandes no muerden.

Vale la pena volver a mencionar de nuevo que las llaves de un hash son siempre únicas, aunque los valores pueden estar duplicados. Los valores de un hash pueden ser todos números, cadenas, valores \texttt{undef}, o una mezcla \footnote{En efecto, cualquier valor escalar, incluyendo otros typos de datos escalares.}. Pero las llaves son siempre arbitrariamente cadenas únicas.

\section{¿ Porque usar un Hash ?}

\label{--Porque-usar-un-Hash--}

Cuando usted escucha por primera vez hablar de hashes, especialmente si usted ha vivido gran parte de su vida productiva como programador en otros lenguajes que no poseen hashes, podría preguntarse, quien querría una de estas criaturas extrañas. Pues bien, la idea general es que usted tendrá un grupo de datos relacionado con otro grupo de datos. Por ejemplo, aquí tenemos algunos de los hashes que podrá encontrar en aplicaciones típicas de Perl:

\vspace{-5pt}

\begin{description}

\setlength{\topsep}{0pt}
\setlength{\itemsep}{0pt}
\item[] Nombres y Apellidos

En este caso, el primer nombre es la llave, y el apellido es el valor. Este tipo de hash requiere, por supuesto, que los nombres sean únicos. Si tiene dos personas con el mismo nombre, este ejemplo no va a funcionar para usted. Con este hash, puedes buscar a cualquiera por el nombre y obtener su apellido. Si usted busca por el nombre \texttt{Walter}, va a obtener el valor \texttt{Vargas}.

\item[] Nombre de Host y dirección IP

Usted debe saber que cada computadora en Internet tiene un nombre de host y una dirección IP. Esto es porque a las máquinas les gusta trabajar con números, pero a los humanos se les hace mas fácil recordar nombres. Los nombres de hosts son cadenas únicas, entonces pueden usarse para hacer este hash. Con este hash puedes buscar por el nombre de host y obtener la dirección IP correspondiente.

\item[] Palabras, contar el número de veces que una palabra aparece.

La idea aquí es, que si usted quiere saber cuantas veces aparece una palabra en un documento dado. Puede hacer un hashs que contenga como llaves del hash a las palabras y como valor el número de repeticiones de la palabra.

\item[] Cédula y Nombre

Este es un ejemplo común, ya sabemos que los números de cédulas son cadenas únicas, entonces podemos tener un hash que contenga como llave el número de cédula y como valor el nombre de la persona.

\end{description}

\vspace{-5pt}
\section{Acceder al elemento de un Hash}

\label{Acceder-al-elemento-de-un-Hash}

Para acceder al elemento de un hash usamos la siguiente sintaxis:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    $hash\{$alguna_llave_del_hash\}
\end{Verbatim}
\vspace{-6pt}
\normalsize
Es bastante similar a la sintaxis que usamos para acceder a un array, pero en este caso vamos a usar llaves en lugar de corchetes alrededor del subíndice (llave). \footnote{Aquí daremos un vistazo dentro de la mente de Larry Wall: Larry decía, vamos a usar llaves en lugar de corchetes porque estamos haciendo algo mas sof\mbox{}isticado que acceder a un array, entonces debemos usar un signo de puntuación mas sof\mbox{}isticado.}

Podemos asignar los valores de la siguiente manera:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    $apellido\{"fred"\}       = "flintstone";
    $apellido\{"barney"\}     = "rubble";
    $apellido\{"hugo"\}       = "Chávez";
\end{Verbatim}
\vspace{-6pt}
\normalsize
Con el hash anterior, podríamos usar el siguiente código para accederlo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    foreach $persona (qw< fred barney hugo >)\{
        print "He oído algo sobre $persona $apellido\{$persona\}.\textbackslash{}n"; 
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
El nombre del hash es de igual manera otro identif\mbox{}icador de Perl (letras, dígitos y pisos bajos, pero no puede iniciar con un número). Y son de un espacio de nombres separado, lo que signif\mbox{}ica que no hay conexión entre la variable \texttt{\$apellido\{"walter''\}}, la subrutina \texttt{\&apellido} o la variable \texttt{\$apellido}.

Por su puesto, la llave de un hash puede ser una expresión, no solo cadenas literales o variables escalares simples. Por ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    $foo = "bar";
    print $apellido\{ $foo . "ney"\};     # Imprime "rubble"
\end{Verbatim}
\vspace{-6pt}
\normalsize
Cuando guardamos algo en un elemento que ya existía en el hash, este sobre escribe al valor anterior:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    $apellido\{"fred"\} = "astaire"; 
\end{Verbatim}
\vspace{-6pt}
\normalsize
Es igual a lo que pasa con los arrays y los escalares.

Si accede a un elemento que no se encuentra en el hash va a obtener \texttt{undef}:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    $granito = $apellido\{"larry"\};  # No hay larry: undef
\end{Verbatim}
\vspace{-6pt}
\normalsize
\section{Hash como un todo}

\label{Hash-como-un-todo}

Para referirse a un hash completo, usamos el signo de porcentaje (\%) como sígil. Entonces, el hash que hemos estado usando en las últimas páginas actualmente se llama \texttt{\%apellido}.

Por conveniencia, un hash puede convertirse en una lista, y luego volver a convertirlo en un hash. Asignando un hash en contexto de lista, donde la lista esta conformada por un conjunto de pares llave-valor.

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    %some_hash = (
        "foo",   35,      "bar",   12.4, 2.5, "hello",
        "wilma", 1.72e30, "betty", "bye\textbackslash{}n"
      )
\end{Verbatim}
\vspace{-6pt}
\normalsize
El valor de un hash (en contexto de lista) es una lista simple de pares llave-valor:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    @any_array = %some_hash; 
\end{Verbatim}
\vspace{-6pt}
\normalsize
A esto le llamamos \emph{desenrollar} el hash, básicamente convertimos el hash en una lista de pares llave-valor. Como era de esperarse, los pares no están necesariamente en el mismo orden de la lista original.

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    print "@any_array\textbackslash{}n"; 
        # vamos a obtener algo como esto: 
        # betty bye (una nueva linea) wilma 1.72e+30 foo 35 2.5 hello bar 12.4
\end{Verbatim}
\vspace{-6pt}
\normalsize
El orden es algo confuso porque Perl mantiene los pares llave-valor en el orden que sea mas conveniente para Perl, de manera que pueda buscarse cualquier item rápidamente. Se usa un hash cuando no nos importa el orden de los elementos, o tenemos una forma fácil de ordenarlos como queramos.

\section{Asignación de Hash}

\label{Asignaci-n-de-Hash}

Esto no es algo común, pero usted puede copiar un hash a otro con la siguiente sintaxis obvia:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    %new_hash = %old_hash; 
\end{Verbatim}
\vspace{-6pt}
\normalsize
Esto es mas complejo para Perl de lo que parece, mientras en otros lenguajes como C o Pascal, es tan simple como copiar un bloque de memoria, las estructuras de datos en Perl sin mas complejas. Entonces, esta linea de código le dice a Perl que desenrolle a \%old\_hash en una lista de pares llaves-valor, y que arme el hash \%new\_hash desde la lista de pares llave-valor.

Es mas común hacer otro tipo de transformaciones con un hash. Por ejemplo, podemos obtener el inverso de un hash así:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    %inverse_hash = reverse %any_hash;
\end{Verbatim}
\vspace{-6pt}
\normalsize
\section{La Gran Flecha}

\label{La-Gran-Flecha}

Cuando asignamos una lista a un hash, algunas veces no es obvio que elementos son llaves y que elementos son valores. Por ejemplo, en esta asignación, los humanos debemos ir contando por la lista diciendo: ``llave, valor, llave, valor, llave, valor \ldots '', para poder determinar si 2.5 es una llave o un valor:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    %some_hash = (
        "foo",   35,      "bar",   12.4, 2.5, "hello",
        "wilma", 1.72e30, "betty", "bye\textbackslash{}n"
    );
\end{Verbatim}
\vspace{-6pt}
\normalsize
¿ No seria agradable que Perl nos diera una manera emparejar las llaves y los valores en contexto de lista ?, Larry también pensaba esto y por eso invento a la f\mbox{}lecha mayor (=\textgreater{}). En Perl, es simplemente un hechizo para representar una coma, por lo que algunas veces se le llama ``la coma gorda''. En la gramática de Perl, cada vez que usted necesite una coma ( , ), puedes usar la f\mbox{}lecha grande, esto va a ser lo mismo para Perl. Por ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    my %last_name = ( # Un hash también puede ser una variable léxica. 
        "fred"  => "flintstone",
        "dino"  => undef, 
        "barney" => "rubble",
        "betty" => "rubble",
    );
\end{Verbatim}
\vspace{-6pt}
\normalsize
Como puede ver, es fácil determinar en el ejemplo anterior, que elementos son valores y que elementos son llaves.

\section{Operadores de Hash}

\label{Operadores-de-Hash}

Naturalmente, hay algunas funciones útiles para poder trabajar con hashs.

\subsection{Las funciones keys y values}

\label{Las-funciones-keys-y-values}

La función \texttt{keys} obtiene una lista de todas las llaves de un hash, mientras que la función \texttt{values} obtiene los valores correspondientes. Si el hash no tiene elementos, ambas funciones retornan una lista vacía.

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    my %hash = ("a" => 1, "b" => 2, "c" => 3); 
    my @k = keys %hash;
    my @v = values %hash;
\end{Verbatim}
\vspace{-6pt}
\normalsize
En el ejemplo anterior \texttt{@k} va a contener ``a'', ``b'', y ``c'', y \texttt{@v} va a contener 1, 2, y 3 en el mismo orden. Recuerde que Perl no mantiene el orden de un hash. Pero cual sea el orden que tenga la lista de llaves va a ser el orden correspondiente de la lista de valores.

En contexto escalar estas funciones retornan la cantidad de elementos en el hash. Ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    my $count = keys %hash;
\end{Verbatim}
\vspace{-6pt}
\normalsize
En un ciclo \texttt{while}, lo podemos usar como expresión en el contexto booleano, por ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    if (%hash)\{
        print "Esto es un valor verdadero\textbackslash{}n";
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
\subsection{La función each}

\label{La-funci-n-each}

Si usted quiere iterar el hash completo, una de las maneras usuales es usar la función \texttt{each}, que retorna un par llave-valor como una lista de dos elementos. En cada evaluación de esta función sobre el mismo hash, va a retornar el siguiente par llave-valor, hasta que todos los elementos sean accedidos. Cuando no hay mas pares, \texttt{each} retorna una lista vacía.

En la práctica, la única manera de usar \texttt{each} es en un ciclo while, por ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    while ( ($key, $value) = each %hash ) \{
        print "$key => $value\textbackslash{}n";
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
Por supuesto, \texttt{each} retorna los pares llave-valor desordenadamente. Si necesita recorrer el hash en orden, simplemente ordena las llaves, por ejemplo:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    foreach $key ( sort keys %hash) \{
        $value = $hash\{$key\};
        print "$key => $value \textbackslash{}n";
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
\subsection{La función exists}

\label{La-funci-n-exists}

Para verif\mbox{}icar que una llave exista en un hash, puede usar la función \texttt{exists}, que retorna un valor verdadero si la llave existe en el hash, de lo contrario retorna falso:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    if (exists $books\{"dino"\}) \{
        print "Hey, there's a library card for dino!\textbackslash{}n";
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
\subsection{La función delete}

\label{La-funci-n-delete}

La función \texttt{delete} remueve una llave de el hash. Si no existe la llave, la función termina, y en ese caso causa una advertencia o un error.

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    my $person = "larry";
    delete $books\{$person\};     
\end{Verbatim}
\vspace{-6pt}
\normalsize
Note que esto no es lo mismo que guardar un elemento como \texttt{undef} en el hash. En efecto, si chequea el hash con \texttt{exists(\$books\{"betty''\})} va a obtener verdadero, luego de usar \texttt{delete}, la llave no puede existir en el hash, pero después de guardar \texttt{undef} la llave va a existir en el hash.

\subsection{Interpolación de un elemento en un Hash}

\label{Interpolaci-n-de-un-elemento-en-un-Hash}

Puedes interpolar un elemento simple de un hash colocándolo entre dobles comillas.

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    foreach $person (sort keys %books) \{
        if ($books\{$person\}) \{
            print "$person has $books\{$person\} items\textbackslash{}n";
        \}
    \}
\end{Verbatim}
\vspace{-6pt}
\normalsize
Pero no es posible interpolar el hash completo, si tratamos de usar \texttt{``\%books''} simplemente obtendremos seis caracteres de (literalmente) \%books.

\subsection{El hash \%ENV}

\label{El-hash--ENV}

Su programa, como cualquier otro programa, corre en un ambiente específ\mbox{}ico, de modo que el programa puede mirar en el ambiente para obtener información de sus alrededores. Perl guarda esa información en el hash \texttt{\%ENV}. Por ejemplo, podemos ver el PATH de la siguiente forma:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},numbers=left]
    print "PATH is $ENV\{PATH\}\textbackslash{}n";
\end{Verbatim}
\vspace{-6pt}
\normalsize
Dependiendo de su sistema operativo particular, va a obtener algo parecido a esto:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},frame=single,label=Terminal]
    PATH is /Users/elsanto/.vim/bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
    
\end{Verbatim}
\vspace{-6pt}
\normalsize
\section{Ejercicios}

\label{ejercicios05}

\vspace{-5pt}

\begin{description}

\setlength{\topsep}{0pt}
\setlength{\itemsep}{0pt}
\item[] 1. Escriba un programa que pregunte al usuario por un nombre e imprima correctamente su apellido. Use los nombres de las personas que usted conozca, o use la tabla siguiente:

\vspace{-6pt}
\small
\begin{Verbatim}[commandchars=\\\{\},frame=single,label=Terminal]
    fred    flinstone 
    barney  rubble
    wilma   flinstone
\end{Verbatim}
\vspace{-6pt}
\normalsize
\item[] 2. Escriba un programa que lea una serie de palabras (una palabra por linea) hasta el f\mbox{}inal de la entrada (End-Of-Input), e imprima un resumen de cuantas veces fue vista cada palabra.

\item[] 3. Escriba un programa que liste todas las llaves de los valores en el hash \texttt{\%ENV}. Imprima los resultados en dos columnas en orden ASCIIbetico. Una vez que tenga el programa funcionando, intente def\mbox{}inir nuevas variables de entorno y asegúrese que estas variables están en la salida de su programa.

\end{description}

\vspace{-5pt}
